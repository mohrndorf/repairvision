Example: [Reder, Egyed - 2012 - Computing Repair Trees for Resolving Inconsistencies in Design Models]

Message m : 
	(∃l1 ∈ m.receiveEvent.covered,
	l2 ∈ m.sendEvent.covered :
	∃a ∈ l2.represents.type.ownedAttribute :
	a != null ⇒ a.type = l1.represents.type)
					∧
	(∀l ∈ m.receiveEvent.covered :
	∃o ∈ l.represents.type.ownedOperation :
	o.name = m.name)

Notiz: Konsistenzregeln wie in M0004

			----------------------------------------------------------------------------------------
			33 - Sequence Diagram and Class Diagram
			----------------------------------------------------------------------------------------
Rule 119: 	The name of a message in a sequence diagram must correspond to a signature of an 
			operation of the receiver’s class  of the message as described in a class diagram. 
			The message and the  signature must have the same name, the same sequence of parameter 
			types and the same return type. The set of operations defined by a class includes 
			inherited ones.
			----------------------------------------------------------------------------------------
Rule 121: 	A message between two objects in a sequence diagram requires a permanent association 
			(association, generalization, or aggregation) to be shown between the  classes in the 
			class  diagram.
Rule 129:	For every message in an interaction there must be either an association or an attribute 
			between the class of its sender and the class of its receiver navigable from the 
			former to the latter class.
			----------------------------------------------------------------------------------------