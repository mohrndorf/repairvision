\chapter{Reparatur-Algorithmus [ENTWURF]}
\label{chapter:algorithm}

Berechnungspipeline: ([Korrespondenzen => Differenz] || abstrakte Reparaturen) 
=> partielle Editierregelerkennung => Reparaturen ableiten => Ranking

\section{Differenzberechnung}

Für die Berechnung der Korrespondenzen kann ein beliebiger Matching-Algorithmus
verwendet werden, welcher Elemente des historischen Modells denen des zu
reparierenden eindeutig zuordnet. Anschließend wird eine technische Differenz
abgeleitet, aus der hervorgeht, welche Modellelemente und Referenzen gelöscht
bzw. hinzugefügt wurden und welche Attributwerte editiert wurden.

\textit{Future-Work:} Die Qualität der erkannten (vervollständigenden)
Reparaturen hängt indirekt mit der Qualität des Matchings zusammen. Die
Zuordnung einzelner Element ist häufig nicht eindeutig möglich. Die Differenz
muss aber nur im Bezug auf einen bestimmten vorgeschlagenen Reparaturvorgang
eindeutig sein. Man könnte das Verfahren so erweitern, dass (bis zu einem
gewissen Grad) mehrdeutige Differenzen betrachtet werden können.

\section{abstrakte Reparaturen}

>Begründung<

Die Berechnung der abstrakten Reparaturen kann unabhängig von der
Differenzberechnung durchgeführt werden. Für die Berechnung der abstrakten
Reparaturen wird nur das zu reparierende Modell betrachtet. Um die abstrakten
Reparaturen zu erzeugen muss die Auswertung der Konsistenzregel durchgeführt
werden. 

Die Konsistenzregeln werden durch Graph-Patterns beschrieben. Ein Graph-Pattern
darf sowohl positive als auch negative Strukturen beschreiben. Jeder Knoten und
jede Kante ist einem Graph-Constraint zugeordnet. Verschiedene Graph-Constraints
können über logische Ausdrücke mit einander verbunden werden.

