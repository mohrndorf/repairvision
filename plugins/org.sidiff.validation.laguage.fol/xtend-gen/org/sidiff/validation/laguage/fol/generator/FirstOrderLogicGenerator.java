/**
 * generated by Xtext 2.10.0
 */
package org.sidiff.validation.laguage.fol.generator;

import com.google.common.collect.Iterators;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import org.sidiff.validation.laguage.fol.firstOrderLogic.And;
import org.sidiff.validation.laguage.fol.firstOrderLogic.AsClassifier;
import org.sidiff.validation.laguage.fol.firstOrderLogic.AsDataType;
import org.sidiff.validation.laguage.fol.firstOrderLogic.BoolConstant;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Capitalize;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Classifier;
import org.sidiff.validation.laguage.fol.firstOrderLogic.ClassifierConstant;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Concatenate;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Constraint;
import org.sidiff.validation.laguage.fol.firstOrderLogic.ConstraintLibrary;
import org.sidiff.validation.laguage.fol.firstOrderLogic.DataType;
import org.sidiff.validation.laguage.fol.firstOrderLogic.DataTypeConstant;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Equals;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Exists;
import org.sidiff.validation.laguage.fol.firstOrderLogic.ForAll;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Formula;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Get;
import org.sidiff.validation.laguage.fol.firstOrderLogic.GetClosure;
import org.sidiff.validation.laguage.fol.firstOrderLogic.GetContainer;
import org.sidiff.validation.laguage.fol.firstOrderLogic.GetContainments;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Greater;
import org.sidiff.validation.laguage.fol.firstOrderLogic.GreaterEqual;
import org.sidiff.validation.laguage.fol.firstOrderLogic.If;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Iff;
import org.sidiff.validation.laguage.fol.firstOrderLogic.IndexOf;
import org.sidiff.validation.laguage.fol.firstOrderLogic.IntConstant;
import org.sidiff.validation.laguage.fol.firstOrderLogic.IsEmpty;
import org.sidiff.validation.laguage.fol.firstOrderLogic.IsInstanceOf;
import org.sidiff.validation.laguage.fol.firstOrderLogic.IsValueLiteralOf;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Not;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Or;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Size;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Smaller;
import org.sidiff.validation.laguage.fol.firstOrderLogic.SmallerEqual;
import org.sidiff.validation.laguage.fol.firstOrderLogic.StringConstant;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Variable;
import org.sidiff.validation.laguage.fol.firstOrderLogic.VariableRef;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Xor;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class FirstOrderLogicGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    HashMap<Object, String> names = new HashMap<Object, String>();
    int constraintCounter = 0;
    int variableCounter = 0;
    int pathCounter = 0;
    ConstraintLibrary ruleBase = this.getRuleBase(resource);
    String packageImportClass = this.getPackageImportClass(ruleBase.getPackageImport());
    String packageName = resource.getURI().trimFileExtension().lastSegment();
    String className = ("ConstraintLibrary" + packageImportClass);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package ");
    _builder.append(packageName);
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("import java.util.ArrayList;");
    _builder.newLine();
    _builder.append("import java.util.HashMap;");
    _builder.newLine();
    _builder.append("import java.util.List;");
    _builder.newLine();
    _builder.append("import java.util.Map;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import ");
    String _packageImport = ruleBase.getPackageImport();
    _builder.append(_packageImport);
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("import org.sidiff.validation.constraint.api.library.*;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.sidiff.validation.constraint.interpreter.*;");
    _builder.newLine();
    _builder.append("import org.sidiff.validation.constraint.interpreter.formulas.binary.*;");
    _builder.newLine();
    _builder.append("import org.sidiff.validation.constraint.interpreter.formulas.predicates.*;");
    _builder.newLine();
    _builder.append("import org.sidiff.validation.constraint.interpreter.formulas.quantifiers.*;");
    _builder.newLine();
    _builder.append("import org.sidiff.validation.constraint.interpreter.formulas.unary.*;");
    _builder.newLine();
    _builder.append("import org.sidiff.validation.constraint.interpreter.terms.*;");
    _builder.newLine();
    _builder.append("import org.sidiff.validation.constraint.interpreter.terms.functions.*;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("public class ");
    _builder.append(className);
    _builder.append(" implements IConstraintLibrary {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private static String documentType = ");
    _builder.append(packageImportClass, "\t");
    _builder.append(".eINSTANCE.getNsURI();");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private static ");
    _builder.append(packageImportClass, "\t");
    _builder.append(" DOMAIN = ");
    _builder.append(packageImportClass, "\t");
    _builder.append(".eINSTANCE;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private static Map<String, IConstraint> rules = new HashMap<>();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("static {");
    _builder.newLine();
    {
      EList<Constraint> _constraints = ruleBase.getConstraints();
      for(final Constraint constraint : _constraints) {
        _builder.append("\t\t");
        _builder.append("addConstraint(create");
        String _name = constraint.getName();
        _builder.append(_name, "\t\t");
        _builder.append("Rule());");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private static void addConstraint(IConstraint rule) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("rules.put(rule.getName(), rule);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@Override\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public String getDocumentType() {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return documentType;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@Override");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public List<IConstraint> getConstraints() {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return new ArrayList<>(rules.values());");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@Override");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public IConstraint getConstraint(String name) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return rules.get(name);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    {
      EList<Constraint> _constraints_1 = ruleBase.getConstraints();
      for(final Constraint constraint_1 : _constraints_1) {
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("public static IConstraint create");
        String _name_1 = constraint_1.getName();
        _builder.append(_name_1, "\t");
        _builder.append("Rule() {");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.newLine();
        {
          Iterable<Variable> _iterable = IteratorExtensions.<Variable>toIterable(Iterators.<Variable>filter(constraint_1.eAllContents(), Variable.class));
          for(final Variable variable : _iterable) {
            _builder.append("\t");
            _builder.append("\t");
            int _plusPlus = variableCounter++;
            String _compileVariable = this.compileVariable(variable, _plusPlus, names);
            _builder.append(_compileVariable, "\t\t");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t");
        _builder.newLine();
        {
          Iterable<VariableRef> _iterable_1 = IteratorExtensions.<VariableRef>toIterable(Iterators.<VariableRef>filter(constraint_1.eAllContents(), VariableRef.class));
          for(final VariableRef getTerm : _iterable_1) {
            _builder.append("\t");
            _builder.append("\t");
            String _xifexpression = null;
            Get _get = getTerm.getGet();
            boolean _tripleNotEquals = (_get != null);
            if (_tripleNotEquals) {
              int _plusPlus_1 = pathCounter++;
              _xifexpression = this.compileVariableRef(getTerm, _plusPlus_1, names);
            }
            _builder.append(_xifexpression, "\t\t");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        int _plusPlus_2 = constraintCounter++;
        String _compileConstraint = this.compileConstraint(constraint_1, _plusPlus_2, names);
        _builder.append(_compileConstraint, "\t\t");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        String _name_2 = constraint_1.getName();
        String ruleName = ("rule_" + _name_2);
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("IConstraint ");
        _builder.append(ruleName, "\t\t");
        _builder.append(" = new Constraint(");
        String _compileType = this.compileType(constraint_1.getVariable().getType());
        _builder.append(_compileType, "\t\t");
        _builder.append(", ");
        String _get_1 = names.get(constraint_1.getVariable());
        _builder.append(_get_1, "\t\t");
        _builder.append(", ");
        String _get_2 = names.get(constraint_1);
        _builder.append(_get_2, "\t\t");
        _builder.append(");");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append(ruleName, "\t\t");
        _builder.append(".setName(\"");
        String _name_3 = constraint_1.getName();
        _builder.append(_name_3, "\t\t");
        _builder.append("\");");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append(ruleName, "\t\t");
        _builder.append(".setMessage(\"");
        String _message = constraint_1.getMessage();
        _builder.append(_message, "\t\t");
        _builder.append("\");");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("return ");
        _builder.append(ruleName, "\t\t");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.append("}");
    _builder.newLine();
    String code = _builder.toString();
    fsa.generateFile((((packageName + "/") + className) + ".java"), code);
    FirstOrderLogicGenerator.saveAsXMI(resource);
  }
  
  public String getPackageImportClass(final String packageImport) {
    int _lastIndexOf = packageImport.lastIndexOf(".");
    int _plus = (_lastIndexOf + 1);
    CharSequence _subSequence = packageImport.subSequence(_plus, packageImport.length());
    return ((String) _subSequence);
  }
  
  public ConstraintLibrary getRuleBase(final Resource resource) {
    EObject _get = resource.getContents().get(0);
    return ((ConstraintLibrary) _get);
  }
  
  public String newName(final HashMap<Object, String> names, final Object astNode, final String name) {
    String newName = name;
    int i = 0;
    while (names.containsKey(newName)) {
      {
        i++;
        newName = (name + Integer.valueOf(i));
      }
    }
    names.put(astNode, newName);
    return name;
  }
  
  public String compileConstraint(final Constraint constraint, final int constraintCounter, final HashMap<Object, String> names) {
    String _name = constraint.getName();
    String name = ((("constraint" + Integer.valueOf(constraintCounter)) + "_") + _name);
    name = this.newName(names, constraint, name);
    String _compileFormula = this.compileFormula(constraint.getFormula(), names);
    String _plus = ((("Formula " + name) + " = ") + _compileFormula);
    return (_plus + ";");
  }
  
  public String compileVariable(final Variable variable, final int counter, final HashMap<Object, String> names) {
    String _name = variable.getName();
    String name = ((("v" + Integer.valueOf(counter)) + "_") + _name);
    name = this.newName(names, variable, name);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Variable ");
    _builder.append(name);
    _builder.append(" = new Variable(\"");
    String _name_1 = variable.getName();
    _builder.append(_name_1);
    _builder.append("\");");
    return _builder.toString();
  }
  
  public String compileVariableRef(final VariableRef path, final int counter, final HashMap<Object, String> names) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("t");
    _builder.append(counter);
    _builder.append("_");
    final Function1<Get, String> _function = (Get it) -> {
      return it.getName().getName();
    };
    String _join = IteratorExtensions.join(IteratorExtensions.<Get, String>map(Iterators.<Get>filter(path.eAllContents(), Get.class), _function), "_");
    _builder.append(_join);
    String name = _builder.toString();
    name = this.newName(names, path, name);
    String getVariable = (("Term " + name) + " = ");
    String _get = names.get(path.getName());
    String _plus = ("new Get(" + _get);
    String _plus_1 = (_plus + ", ");
    String _compileFeature = this.compileFeature(path.getGet().getName());
    String _plus_2 = (_plus_1 + _compileFeature);
    String _plus_3 = (_plus_2 + ")");
    StringBuffer code = new StringBuffer(_plus_3);
    this.compileGet(path.getGet().getNext(), code);
    return ((getVariable + code) + ";");
  }
  
  public void compileGet(final Get get, final StringBuffer code) {
    if ((get != null)) {
      code.insert(0, "new Get(");
      String _compileFeature = this.compileFeature(get.getName());
      String _plus = (", " + _compileFeature);
      String _plus_1 = (_plus + ")");
      code.append(_plus_1);
      this.compileGet(get.getNext(), code);
    }
  }
  
  public String compileType(final EClassifier type) {
    String _name = type.getName();
    String _plus = ("DOMAIN.get" + _name);
    return (_plus + "()");
  }
  
  public String compileType(final Classifier type, final HashMap<Object, String> names) {
    if ((type instanceof ClassifierConstant)) {
      return this.compileType(((ClassifierConstant)type).getConstant());
    } else {
      if ((type instanceof AsClassifier)) {
        return this.compileFormula(((AsClassifier)type).getTerm(), names);
      }
    }
    return null;
  }
  
  public String compileType(final DataType type, final HashMap<Object, String> names) {
    if ((type instanceof DataTypeConstant)) {
      return this.compileType(((DataTypeConstant)type).getConstant());
    } else {
      if ((type instanceof AsDataType)) {
        return this.compileFormula(((AsDataType)type).getTerm(), names);
      }
    }
    return null;
  }
  
  public String compileFeature(final EStructuralFeature feature) {
    String _name = feature.getEContainingClass().getName();
    String _plus = ("DOMAIN.get" + _name);
    String _plus_1 = (_plus + "_");
    String _firstUpper = StringExtensions.toFirstUpper(feature.getName());
    String _plus_2 = (_plus_1 + _firstUpper);
    return (_plus_2 + "()");
  }
  
  protected String _compileFormula(final Formula formula, final HashMap<Object, String> names) {
    return "MISSING_FORMULA";
  }
  
  protected String _compileFormula(final Iff iff, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(iff.getLeft(), names);
    String _plus = ("new Iff(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(iff.getRight(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final If ifFormula, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(ifFormula.getLeft(), names);
    String _plus = ("new If(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(ifFormula.getRight(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final Xor xor, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(xor.getLeft(), names);
    String _plus = ("new Xor(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(xor.getRight(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final Or or, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(or.getLeft(), names);
    String _plus = ("new Or(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(or.getRight(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final And and, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(and.getLeft(), names);
    String _plus = ("new And(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(and.getRight(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final Not not, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(not.getNot(), names);
    String _plus = ("new Not(" + _compileFormula);
    return (_plus + ")");
  }
  
  protected String _compileFormula(final IsEmpty isEmpty, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(isEmpty.getTerm(), names);
    String _plus = ("new IsEmpty(" + _compileFormula);
    return (_plus + ")");
  }
  
  protected String _compileFormula(final Equals equals, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(equals.getLeft(), names);
    String _plus = ("new Equality(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(equals.getRight(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final Greater greater, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(greater.getLeft(), names);
    String _plus = ("new IsGreater(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(greater.getRight(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final GreaterEqual greaterEqual, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(greaterEqual.getLeft(), names);
    String _plus = ("new IsGreaterEqual(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(greaterEqual.getRight(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final Smaller smaller, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(smaller.getLeft(), names);
    String _plus = ("new IsSmaller(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(smaller.getRight(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final SmallerEqual smallerEqual, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(smallerEqual.getLeft(), names);
    String _plus = ("new IsSmallerEqual(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(smallerEqual.getRight(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final IsInstanceOf isInstanceOf, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(isInstanceOf.getTerm(), names);
    String _plus = ("new IsInstanceOf(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileType = this.compileType(isInstanceOf.getType(), names);
    String _plus_2 = (_plus_1 + _compileType);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final IsValueLiteralOf isValueLiteralOf, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(isValueLiteralOf.getTerm(), names);
    String _plus = ("new IsValueLiteralOf(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileType = this.compileType(isValueLiteralOf.getType(), names);
    String _plus_2 = (_plus_1 + _compileType);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final ForAll forAll, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(forAll.getName(), names);
    String _plus = ("new ForAll(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(forAll.getIteration(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    String _plus_3 = (_plus_2 + ", ");
    String _compileFormula_2 = this.compileFormula(forAll.getFormula(), names);
    String _plus_4 = (_plus_3 + _compileFormula_2);
    return (_plus_4 + ")");
  }
  
  protected String _compileFormula(final Exists exists, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(exists.getName(), names);
    String _plus = ("new Exists(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(exists.getIteration(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    String _plus_3 = (_plus_2 + ", ");
    String _compileFormula_2 = this.compileFormula(exists.getFormula(), names);
    String _plus_4 = (_plus_3 + _compileFormula_2);
    return (_plus_4 + ")");
  }
  
  protected String _compileFormula(final IntConstant integer, final HashMap<Object, String> names) {
    int _value = integer.getValue();
    String _plus = ("new Constant(" + Integer.valueOf(_value));
    return (_plus + ")");
  }
  
  protected String _compileFormula(final StringConstant string, final HashMap<Object, String> names) {
    String _value = string.getValue();
    String _plus = ("new Constant(\"" + _value);
    return (_plus + "\")");
  }
  
  protected String _compileFormula(final BoolConstant bool, final HashMap<Object, String> names) {
    boolean _equalsIgnoreCase = bool.getValue().equalsIgnoreCase("true");
    if (_equalsIgnoreCase) {
      return "BoolConstant.TRUE";
    } else {
      return "BoolConstant.FALSE";
    }
  }
  
  protected String _compileFormula(final Capitalize capitalize, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(capitalize.getString(), names);
    String _plus = ("new Capitalize(" + _compileFormula);
    return (_plus + ")");
  }
  
  protected String _compileFormula(final Concatenate concatenate, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(concatenate.getLeft(), names);
    String _plus = ("new Concatenate(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFormula_1 = this.compileFormula(concatenate.getRight(), names);
    String _plus_2 = (_plus_1 + _compileFormula_1);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final GetClosure getClosure, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(getClosure.getElement(), names);
    String _plus = ("new GetClosure(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFeature = this.compileFeature(getClosure.getFeature());
    String _plus_2 = (_plus_1 + _compileFeature);
    return (_plus_2 + ")");
  }
  
  protected String _compileFormula(final GetContainer getContainer, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(getContainer.getElement(), names);
    String _plus = ("new GetContainer(" + _compileFormula);
    return (_plus + ")");
  }
  
  protected String _compileFormula(final GetContainments getContainments, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(getContainments.getElement(), names);
    String _plus = ("new GetContainments(" + _compileFormula);
    return (_plus + ")");
  }
  
  protected String _compileFormula(final Size size, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(size.getElements(), names);
    String _plus = ("new Size(" + _compileFormula);
    return (_plus + ")");
  }
  
  protected String _compileFormula(final IndexOf indexOf, final HashMap<Object, String> names) {
    String _compileFormula = this.compileFormula(indexOf.getContainer(), names);
    String _plus = ("new IndexOf(" + _compileFormula);
    String _plus_1 = (_plus + ", ");
    String _compileFeature = this.compileFeature(indexOf.getFeature());
    String _plus_2 = (_plus_1 + _compileFeature);
    String _plus_3 = (_plus_2 + ", ");
    String _compileFormula_1 = this.compileFormula(indexOf.getElement(), names);
    String _plus_4 = (_plus_3 + _compileFormula_1);
    return (_plus_4 + ")");
  }
  
  protected String _compileFormula(final VariableRef variable, final HashMap<Object, String> names) {
    Get _get = variable.getGet();
    boolean _tripleNotEquals = (_get != null);
    if (_tripleNotEquals) {
      return names.get(variable);
    } else {
      return names.get(variable.getName());
    }
  }
  
  protected String _compileFormula(final Variable variable, final HashMap<Object, String> names) {
    return names.get(variable);
  }
  
  public static void saveAsXMI(final Resource resource) {
    try {
      EObject root = resource.getContents().get(0);
      Map<EObject, EObject> trace = FirstOrderLogicGenerator.deepCopy(root);
      EObject copyRoot = trace.get(root);
      ResourceSetImpl resourceSet = new ResourceSetImpl();
      Resource xmiResource = resourceSet.createResource(resource.getURI().trimFileExtension().appendFileExtension("xmi"));
      xmiResource.getContents().add(copyRoot);
      xmiResource.save(Collections.<Object, Object>emptyMap());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Creates a deep copy (i.e. full tree content) of the given object.
   * 
   * @param original
   *            The root object which will be copied.
   * @return The copy trace: Original -> Copy
   */
  public static Map<EObject, EObject> deepCopy(final EObject original) {
    EcoreUtil.Copier copier = new EcoreUtil.Copier();
    copier.copy(original);
    copier.copyReferences();
    return copier;
  }
  
  public String compileFormula(final EObject bool, final HashMap<Object, String> names) {
    if (bool instanceof BoolConstant) {
      return _compileFormula((BoolConstant)bool, names);
    } else if (bool instanceof Capitalize) {
      return _compileFormula((Capitalize)bool, names);
    } else if (bool instanceof Concatenate) {
      return _compileFormula((Concatenate)bool, names);
    } else if (bool instanceof Exists) {
      return _compileFormula((Exists)bool, names);
    } else if (bool instanceof ForAll) {
      return _compileFormula((ForAll)bool, names);
    } else if (bool instanceof GetClosure) {
      return _compileFormula((GetClosure)bool, names);
    } else if (bool instanceof GetContainer) {
      return _compileFormula((GetContainer)bool, names);
    } else if (bool instanceof GetContainments) {
      return _compileFormula((GetContainments)bool, names);
    } else if (bool instanceof IndexOf) {
      return _compileFormula((IndexOf)bool, names);
    } else if (bool instanceof IntConstant) {
      return _compileFormula((IntConstant)bool, names);
    } else if (bool instanceof Not) {
      return _compileFormula((Not)bool, names);
    } else if (bool instanceof Size) {
      return _compileFormula((Size)bool, names);
    } else if (bool instanceof StringConstant) {
      return _compileFormula((StringConstant)bool, names);
    } else if (bool instanceof VariableRef) {
      return _compileFormula((VariableRef)bool, names);
    } else if (bool instanceof And) {
      return _compileFormula((And)bool, names);
    } else if (bool instanceof Equals) {
      return _compileFormula((Equals)bool, names);
    } else if (bool instanceof Greater) {
      return _compileFormula((Greater)bool, names);
    } else if (bool instanceof GreaterEqual) {
      return _compileFormula((GreaterEqual)bool, names);
    } else if (bool instanceof If) {
      return _compileFormula((If)bool, names);
    } else if (bool instanceof Iff) {
      return _compileFormula((Iff)bool, names);
    } else if (bool instanceof IsEmpty) {
      return _compileFormula((IsEmpty)bool, names);
    } else if (bool instanceof IsInstanceOf) {
      return _compileFormula((IsInstanceOf)bool, names);
    } else if (bool instanceof IsValueLiteralOf) {
      return _compileFormula((IsValueLiteralOf)bool, names);
    } else if (bool instanceof Or) {
      return _compileFormula((Or)bool, names);
    } else if (bool instanceof Smaller) {
      return _compileFormula((Smaller)bool, names);
    } else if (bool instanceof SmallerEqual) {
      return _compileFormula((SmallerEqual)bool, names);
    } else if (bool instanceof Xor) {
      return _compileFormula((Xor)bool, names);
    } else if (bool instanceof Formula) {
      return _compileFormula((Formula)bool, names);
    } else if (bool instanceof Variable) {
      return _compileFormula((Variable)bool, names);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(bool, names).toString());
    }
  }
}
