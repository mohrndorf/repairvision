/*
 * generated by Xtext 2.10.0
 */
package org.sidiff.validation.laguage.fol.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.sidiff.validation.laguage.fol.firstOrderLogic.And;
import org.sidiff.validation.laguage.fol.firstOrderLogic.BoolConstant;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Constraint;
import org.sidiff.validation.laguage.fol.firstOrderLogic.ConstraintLibrary;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Equals;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Exists;
import org.sidiff.validation.laguage.fol.firstOrderLogic.FirstOrderLogicPackage;
import org.sidiff.validation.laguage.fol.firstOrderLogic.ForAll;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Get;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Greater;
import org.sidiff.validation.laguage.fol.firstOrderLogic.GreaterEqual;
import org.sidiff.validation.laguage.fol.firstOrderLogic.If;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Iff;
import org.sidiff.validation.laguage.fol.firstOrderLogic.IntConstant;
import org.sidiff.validation.laguage.fol.firstOrderLogic.IsEmpty;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Not;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Or;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Smaller;
import org.sidiff.validation.laguage.fol.firstOrderLogic.SmallerEqual;
import org.sidiff.validation.laguage.fol.firstOrderLogic.StringConstant;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Variable;
import org.sidiff.validation.laguage.fol.firstOrderLogic.VariableRef;
import org.sidiff.validation.laguage.fol.firstOrderLogic.Xor;
import org.sidiff.validation.laguage.fol.services.FirstOrderLogicGrammarAccess;

@SuppressWarnings("all")
public class FirstOrderLogicSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FirstOrderLogicGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FirstOrderLogicPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FirstOrderLogicPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case FirstOrderLogicPackage.BOOL_CONSTANT:
				sequence_BoolConstant(context, (BoolConstant) semanticObject); 
				return; 
			case FirstOrderLogicPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case FirstOrderLogicPackage.CONSTRAINT_LIBRARY:
				sequence_ConstraintLibrary(context, (ConstraintLibrary) semanticObject); 
				return; 
			case FirstOrderLogicPackage.EQUALS:
				sequence_Equals(context, (Equals) semanticObject); 
				return; 
			case FirstOrderLogicPackage.EXISTS:
				sequence_Exists(context, (Exists) semanticObject); 
				return; 
			case FirstOrderLogicPackage.FOR_ALL:
				sequence_ForAll(context, (ForAll) semanticObject); 
				return; 
			case FirstOrderLogicPackage.GET:
				sequence_Get(context, (Get) semanticObject); 
				return; 
			case FirstOrderLogicPackage.GREATER:
				sequence_Greater(context, (Greater) semanticObject); 
				return; 
			case FirstOrderLogicPackage.GREATER_EQUAL:
				sequence_GreaterEqual(context, (GreaterEqual) semanticObject); 
				return; 
			case FirstOrderLogicPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case FirstOrderLogicPackage.IFF:
				sequence_Iff(context, (Iff) semanticObject); 
				return; 
			case FirstOrderLogicPackage.INT_CONSTANT:
				sequence_Constant(context, (IntConstant) semanticObject); 
				return; 
			case FirstOrderLogicPackage.IS_EMPTY:
				sequence_IsEmpty(context, (IsEmpty) semanticObject); 
				return; 
			case FirstOrderLogicPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case FirstOrderLogicPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case FirstOrderLogicPackage.SMALLER:
				sequence_Smaller(context, (Smaller) semanticObject); 
				return; 
			case FirstOrderLogicPackage.SMALLER_EQUAL:
				sequence_SmallerEqual(context, (SmallerEqual) semanticObject); 
				return; 
			case FirstOrderLogicPackage.STRING_CONSTANT:
				sequence_Constant(context, (StringConstant) semanticObject); 
				return; 
			case FirstOrderLogicPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case FirstOrderLogicPackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			case FirstOrderLogicPackage.XOR:
				sequence_Xor(context, (Xor) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Formula returns And
	 *     Iff returns And
	 *     Iff.Iff_1_0 returns And
	 *     BinaryFormula returns And
	 *     If returns And
	 *     If.If_1_0 returns And
	 *     Xor returns And
	 *     Xor.Xor_1_0 returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     BooleanExpression returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=BooleanExpression)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightBooleanExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns BoolConstant
	 *     Iff returns BoolConstant
	 *     Iff.Iff_1_0 returns BoolConstant
	 *     BinaryFormula returns BoolConstant
	 *     If returns BoolConstant
	 *     If.If_1_0 returns BoolConstant
	 *     Xor returns BoolConstant
	 *     Xor.Xor_1_0 returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     BooleanExpression returns BoolConstant
	 *     BoolConstant returns BoolConstant
	 *     Term returns BoolConstant
	 *     Constant returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_BoolConstant(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns IntConstant
	 *     Constant returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Constant(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns StringConstant
	 *     Constant returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Constant(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintLibrary returns ConstraintLibrary
	 *
	 * Constraint:
	 *     (domain=STRING packageImport=STRING constraints+=Constraint*)
	 */
	protected void sequence_ConstraintLibrary(ISerializationContext context, ConstraintLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (name=ID message=STRING variable=Variable formula=Formula)
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.CONSTRAINT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.CONSTRAINT__NAME));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.CONSTRAINT__MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.CONSTRAINT__MESSAGE));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.CONSTRAINT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.CONSTRAINT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.CONSTRAINT__FORMULA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.CONSTRAINT__FORMULA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstraintAccess().getMessageSTRINGTerminalRuleCall_3_0(), semanticObject.getMessage());
		feeder.accept(grammarAccess.getConstraintAccess().getVariableVariableParserRuleCall_5_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getConstraintAccess().getFormulaFormulaParserRuleCall_7_0(), semanticObject.getFormula());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Equals
	 *     Iff returns Equals
	 *     Iff.Iff_1_0 returns Equals
	 *     BinaryFormula returns Equals
	 *     If returns Equals
	 *     If.If_1_0 returns Equals
	 *     Xor returns Equals
	 *     Xor.Xor_1_0 returns Equals
	 *     Or returns Equals
	 *     Or.Or_1_0 returns Equals
	 *     And returns Equals
	 *     And.And_1_0 returns Equals
	 *     Predicate returns Equals
	 *     Equals returns Equals
	 *     BooleanExpression returns Equals
	 *
	 * Constraint:
	 *     (left=Term right=Term)
	 */
	protected void sequence_Equals(ISerializationContext context, Equals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.EQUALS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.EQUALS__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.EQUALS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.EQUALS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsAccess().getLeftTermParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualsAccess().getRightTermParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Exists
	 *     Iff returns Exists
	 *     Iff.Iff_1_0 returns Exists
	 *     BinaryFormula returns Exists
	 *     If returns Exists
	 *     If.If_1_0 returns Exists
	 *     Xor returns Exists
	 *     Xor.Xor_1_0 returns Exists
	 *     Or returns Exists
	 *     Or.Or_1_0 returns Exists
	 *     And returns Exists
	 *     And.And_1_0 returns Exists
	 *     Quantifier returns Exists
	 *     Exists returns Exists
	 *     BooleanExpression returns Exists
	 *
	 * Constraint:
	 *     (name=Variable iteration=Term formula=Formula)
	 */
	protected void sequence_Exists(ISerializationContext context, Exists semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__NAME));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__ITERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__ITERATION));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__FORMULA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__FORMULA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistsAccess().getNameVariableParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExistsAccess().getIterationTermParserRuleCall_4_0(), semanticObject.getIteration());
		feeder.accept(grammarAccess.getExistsAccess().getFormulaFormulaParserRuleCall_6_0(), semanticObject.getFormula());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns ForAll
	 *     Iff returns ForAll
	 *     Iff.Iff_1_0 returns ForAll
	 *     BinaryFormula returns ForAll
	 *     If returns ForAll
	 *     If.If_1_0 returns ForAll
	 *     Xor returns ForAll
	 *     Xor.Xor_1_0 returns ForAll
	 *     Or returns ForAll
	 *     Or.Or_1_0 returns ForAll
	 *     And returns ForAll
	 *     And.And_1_0 returns ForAll
	 *     Quantifier returns ForAll
	 *     ForAll returns ForAll
	 *     BooleanExpression returns ForAll
	 *
	 * Constraint:
	 *     (name=Variable iteration=Term formula=Formula)
	 */
	protected void sequence_ForAll(ISerializationContext context, ForAll semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__NAME));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__ITERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__ITERATION));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__FORMULA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.QUANTIFIER__FORMULA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForAllAccess().getNameVariableParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getForAllAccess().getIterationTermParserRuleCall_4_0(), semanticObject.getIteration());
		feeder.accept(grammarAccess.getForAllAccess().getFormulaFormulaParserRuleCall_6_0(), semanticObject.getFormula());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Get returns Get
	 *
	 * Constraint:
	 *     (type=ID? name=[EStructuralFeature|ID] next=Get?)
	 */
	protected void sequence_Get(ISerializationContext context, Get semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns GreaterEqual
	 *     Iff returns GreaterEqual
	 *     Iff.Iff_1_0 returns GreaterEqual
	 *     BinaryFormula returns GreaterEqual
	 *     If returns GreaterEqual
	 *     If.If_1_0 returns GreaterEqual
	 *     Xor returns GreaterEqual
	 *     Xor.Xor_1_0 returns GreaterEqual
	 *     Or returns GreaterEqual
	 *     Or.Or_1_0 returns GreaterEqual
	 *     And returns GreaterEqual
	 *     And.And_1_0 returns GreaterEqual
	 *     Predicate returns GreaterEqual
	 *     Inequality returns GreaterEqual
	 *     GreaterEqual returns GreaterEqual
	 *     BooleanExpression returns GreaterEqual
	 *
	 * Constraint:
	 *     (left=Term right=Term)
	 */
	protected void sequence_GreaterEqual(ISerializationContext context, GreaterEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GREATER_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GREATER_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GREATER_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GREATER_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreaterEqualAccess().getLeftTermParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGreaterEqualAccess().getRightTermParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Greater
	 *     Iff returns Greater
	 *     Iff.Iff_1_0 returns Greater
	 *     BinaryFormula returns Greater
	 *     If returns Greater
	 *     If.If_1_0 returns Greater
	 *     Xor returns Greater
	 *     Xor.Xor_1_0 returns Greater
	 *     Or returns Greater
	 *     Or.Or_1_0 returns Greater
	 *     And returns Greater
	 *     And.And_1_0 returns Greater
	 *     Predicate returns Greater
	 *     Inequality returns Greater
	 *     Greater returns Greater
	 *     BooleanExpression returns Greater
	 *
	 * Constraint:
	 *     (left=Term right=Term)
	 */
	protected void sequence_Greater(ISerializationContext context, Greater semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GREATER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GREATER__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.GREATER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.GREATER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreaterAccess().getLeftTermParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGreaterAccess().getRightTermParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns If
	 *     Iff returns If
	 *     Iff.Iff_1_0 returns If
	 *     BinaryFormula returns If
	 *     If returns If
	 *     If.If_1_0 returns If
	 *     Xor returns If
	 *     Xor.Xor_1_0 returns If
	 *     Or returns If
	 *     Or.Or_1_0 returns If
	 *     And returns If
	 *     And.And_1_0 returns If
	 *     BooleanExpression returns If
	 *
	 * Constraint:
	 *     (left=If_If_1_0 right=Xor)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IF__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IF__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IF__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IF__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfAccess().getIfLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getIfAccess().getRightXorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Iff
	 *     Iff returns Iff
	 *     Iff.Iff_1_0 returns Iff
	 *     BinaryFormula returns Iff
	 *     If returns Iff
	 *     If.If_1_0 returns Iff
	 *     Xor returns Iff
	 *     Xor.Xor_1_0 returns Iff
	 *     Or returns Iff
	 *     Or.Or_1_0 returns Iff
	 *     And returns Iff
	 *     And.And_1_0 returns Iff
	 *     BooleanExpression returns Iff
	 *
	 * Constraint:
	 *     (left=Iff_Iff_1_0 right=BinaryFormula)
	 */
	protected void sequence_Iff(ISerializationContext context, Iff semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IFF__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IFF__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IFF__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IFF__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIffAccess().getIffLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getIffAccess().getRightBinaryFormulaParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns IsEmpty
	 *     Iff returns IsEmpty
	 *     Iff.Iff_1_0 returns IsEmpty
	 *     BinaryFormula returns IsEmpty
	 *     If returns IsEmpty
	 *     If.If_1_0 returns IsEmpty
	 *     Xor returns IsEmpty
	 *     Xor.Xor_1_0 returns IsEmpty
	 *     Or returns IsEmpty
	 *     Or.Or_1_0 returns IsEmpty
	 *     And returns IsEmpty
	 *     And.And_1_0 returns IsEmpty
	 *     Predicate returns IsEmpty
	 *     IsEmpty returns IsEmpty
	 *     BooleanExpression returns IsEmpty
	 *
	 * Constraint:
	 *     term=Term
	 */
	protected void sequence_IsEmpty(ISerializationContext context, IsEmpty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.IS_EMPTY__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.IS_EMPTY__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsEmptyAccess().getTermTermParserRuleCall_1_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Not
	 *     Iff returns Not
	 *     Iff.Iff_1_0 returns Not
	 *     BinaryFormula returns Not
	 *     If returns Not
	 *     If.If_1_0 returns Not
	 *     Xor returns Not
	 *     Xor.Xor_1_0 returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     UnaryFormula returns Not
	 *     Not returns Not
	 *     BooleanExpression returns Not
	 *
	 * Constraint:
	 *     not=Formula
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.NOT__NOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.NOT__NOT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotAccess().getNotFormulaParserRuleCall_2_0(), semanticObject.getNot());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Or
	 *     Iff returns Or
	 *     Iff.Iff_1_0 returns Or
	 *     BinaryFormula returns Or
	 *     If returns Or
	 *     If.If_1_0 returns Or
	 *     Xor returns Or
	 *     Xor.Xor_1_0 returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     BooleanExpression returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns SmallerEqual
	 *     Iff returns SmallerEqual
	 *     Iff.Iff_1_0 returns SmallerEqual
	 *     BinaryFormula returns SmallerEqual
	 *     If returns SmallerEqual
	 *     If.If_1_0 returns SmallerEqual
	 *     Xor returns SmallerEqual
	 *     Xor.Xor_1_0 returns SmallerEqual
	 *     Or returns SmallerEqual
	 *     Or.Or_1_0 returns SmallerEqual
	 *     And returns SmallerEqual
	 *     And.And_1_0 returns SmallerEqual
	 *     Predicate returns SmallerEqual
	 *     Inequality returns SmallerEqual
	 *     SmallerEqual returns SmallerEqual
	 *     BooleanExpression returns SmallerEqual
	 *
	 * Constraint:
	 *     (left=Term right=Term)
	 */
	protected void sequence_SmallerEqual(ISerializationContext context, SmallerEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.SMALLER_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.SMALLER_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.SMALLER_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.SMALLER_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSmallerEqualAccess().getLeftTermParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSmallerEqualAccess().getRightTermParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Smaller
	 *     Iff returns Smaller
	 *     Iff.Iff_1_0 returns Smaller
	 *     BinaryFormula returns Smaller
	 *     If returns Smaller
	 *     If.If_1_0 returns Smaller
	 *     Xor returns Smaller
	 *     Xor.Xor_1_0 returns Smaller
	 *     Or returns Smaller
	 *     Or.Or_1_0 returns Smaller
	 *     And returns Smaller
	 *     And.And_1_0 returns Smaller
	 *     Predicate returns Smaller
	 *     Inequality returns Smaller
	 *     Smaller returns Smaller
	 *     BooleanExpression returns Smaller
	 *
	 * Constraint:
	 *     (left=Term right=Term)
	 */
	protected void sequence_Smaller(ISerializationContext context, Smaller semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.SMALLER__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.SMALLER__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.SMALLER__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.SMALLER__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSmallerAccess().getLeftTermParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSmallerAccess().getRightTermParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     (name=[Variable|ID] get=Get?)
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (type=ID name=ID)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.VARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getTypeIDTerminalRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Formula returns Xor
	 *     Iff returns Xor
	 *     Iff.Iff_1_0 returns Xor
	 *     BinaryFormula returns Xor
	 *     If returns Xor
	 *     If.If_1_0 returns Xor
	 *     Xor returns Xor
	 *     Xor.Xor_1_0 returns Xor
	 *     Or returns Xor
	 *     Or.Or_1_0 returns Xor
	 *     And returns Xor
	 *     And.And_1_0 returns Xor
	 *     BooleanExpression returns Xor
	 *
	 * Constraint:
	 *     (left=Xor_Xor_1_0 right=Or)
	 */
	protected void sequence_Xor(ISerializationContext context, Xor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.XOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.XOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, FirstOrderLogicPackage.Literals.XOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FirstOrderLogicPackage.Literals.XOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXorAccess().getXorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getXorAccess().getRightOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
