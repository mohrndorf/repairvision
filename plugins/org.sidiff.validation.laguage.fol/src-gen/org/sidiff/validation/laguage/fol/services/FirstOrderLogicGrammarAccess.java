/*
 * generated by Xtext 2.10.0
 */
package org.sidiff.validation.laguage.fol.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class FirstOrderLogicGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ConstraintLibraryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.ConstraintLibrary");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDomainKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDomainAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDomainSTRINGTerminalRuleCall_1_0 = (RuleCall)cDomainAssignment_1.eContents().get(0);
		private final Keyword cImportKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPackageImportAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPackageImportSTRINGTerminalRuleCall_3_0 = (RuleCall)cPackageImportAssignment_3.eContents().get(0);
		private final Assignment cConstraintsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConstraintsConstraintParserRuleCall_4_0 = (RuleCall)cConstraintsAssignment_4.eContents().get(0);
		
		//// NOTE: escape keywords with ^keyword
		//ConstraintLibrary:
		//	"domain" domain=STRING 'import' packageImport=STRING
		//	constraints+=Constraint*;
		@Override public ParserRule getRule() { return rule; }
		
		//"domain" domain=STRING 'import' packageImport=STRING constraints+=Constraint*
		public Group getGroup() { return cGroup; }
		
		//"domain"
		public Keyword getDomainKeyword_0() { return cDomainKeyword_0; }
		
		//domain=STRING
		public Assignment getDomainAssignment_1() { return cDomainAssignment_1; }
		
		//STRING
		public RuleCall getDomainSTRINGTerminalRuleCall_1_0() { return cDomainSTRINGTerminalRuleCall_1_0; }
		
		//'import'
		public Keyword getImportKeyword_2() { return cImportKeyword_2; }
		
		//packageImport=STRING
		public Assignment getPackageImportAssignment_3() { return cPackageImportAssignment_3; }
		
		//STRING
		public RuleCall getPackageImportSTRINGTerminalRuleCall_3_0() { return cPackageImportSTRINGTerminalRuleCall_3_0; }
		
		//constraints+=Constraint*
		public Assignment getConstraintsAssignment_4() { return cConstraintsAssignment_4; }
		
		//Constraint
		public RuleCall getConstraintsConstraintParserRuleCall_4_0() { return cConstraintsConstraintParserRuleCall_4_0; }
	}
	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Constraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstraintKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cMessageKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMessageAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMessageSTRINGTerminalRuleCall_3_0 = (RuleCall)cMessageAssignment_3.eContents().get(0);
		private final Keyword cContextKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cVariableAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cVariableVariableParserRuleCall_5_0 = (RuleCall)cVariableAssignment_5.eContents().get(0);
		private final Keyword cColonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cFormulaAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cFormulaFormulaParserRuleCall_7_0 = (RuleCall)cFormulaAssignment_7.eContents().get(0);
		
		//Constraint:
		//	'constraint' name=ID 'message' message=STRING 'context' variable=Variable ':' formula=Formula;
		@Override public ParserRule getRule() { return rule; }
		
		//'constraint' name=ID 'message' message=STRING 'context' variable=Variable ':' formula=Formula
		public Group getGroup() { return cGroup; }
		
		//'constraint'
		public Keyword getConstraintKeyword_0() { return cConstraintKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'message'
		public Keyword getMessageKeyword_2() { return cMessageKeyword_2; }
		
		//message=STRING
		public Assignment getMessageAssignment_3() { return cMessageAssignment_3; }
		
		//STRING
		public RuleCall getMessageSTRINGTerminalRuleCall_3_0() { return cMessageSTRINGTerminalRuleCall_3_0; }
		
		//'context'
		public Keyword getContextKeyword_4() { return cContextKeyword_4; }
		
		//variable=Variable
		public Assignment getVariableAssignment_5() { return cVariableAssignment_5; }
		
		//Variable
		public RuleCall getVariableVariableParserRuleCall_5_0() { return cVariableVariableParserRuleCall_5_0; }
		
		//':'
		public Keyword getColonKeyword_6() { return cColonKeyword_6; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_7() { return cFormulaAssignment_7; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_7_0() { return cFormulaFormulaParserRuleCall_7_0; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeIDTerminalRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Variable:
		//	type=ID name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=ID name=ID
		public Group getGroup() { return cGroup; }
		
		//type=ID
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//ID
		public RuleCall getTypeIDTerminalRuleCall_0_0() { return cTypeIDTerminalRuleCall_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class FormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Formula");
		private final RuleCall cBinaryFormulaParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// formula:
		/// * 
		// * Precedence: not, and, or, xor, if/implies, iff
		// * 
		// * To define the precedence we must write the rule for the operator with less precedence in 
		// * terms of the rule for the operator with higher precedence. This means that in the grammar, 
		// * the rules for operators with less precedence are defined first.
		// * / // binary formulas:
		//// TODO: How to make If, Xor,... inherit from BinaryFormula?
		//// http://www.lorenzobettini.it/2014/02/switching-from-an-inferred-ecore-model-to-an-imported-one-in-your-xtext-grammar/
		//Formula:
		//	BinaryFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//BinaryFormula
		public RuleCall getBinaryFormulaParserRuleCall() { return cBinaryFormulaParserRuleCall; }
	}
	public class BinaryFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.BinaryFormula");
		private final RuleCall cIffParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//BinaryFormula Formula:
		//	Iff
		@Override public ParserRule getRule() { return rule; }
		
		//Iff
		public RuleCall getIffParserRuleCall() { return cIffParserRuleCall; }
	}
	public class IffElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Iff");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIfParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIffLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightIfParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Iff Formula:
		//	If ({Iff.left=current} "=" right=If)*
		@Override public ParserRule getRule() { return rule; }
		
		//If ({Iff.left=current} "=" right=If)*
		public Group getGroup() { return cGroup; }
		
		//If
		public RuleCall getIfParserRuleCall_0() { return cIfParserRuleCall_0; }
		
		//({Iff.left=current} "=" right=If)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Iff.left=current}
		public Action getIffLeftAction_1_0() { return cIffLeftAction_1_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }
		
		//right=If
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//If
		public RuleCall getRightIfParserRuleCall_1_2_0() { return cRightIfParserRuleCall_1_2_0; }
	}
	public class IfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.If");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIfLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cImpliesKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//If Formula:
		//	Xor ({If.left=current} "implies" right=Xor)*
		@Override public ParserRule getRule() { return rule; }
		
		//Xor ({If.left=current} "implies" right=Xor)*
		public Group getGroup() { return cGroup; }
		
		//Xor
		public RuleCall getXorParserRuleCall_0() { return cXorParserRuleCall_0; }
		
		//({If.left=current} "implies" right=Xor)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{If.left=current}
		public Action getIfLeftAction_1_0() { return cIfLeftAction_1_0; }
		
		//"implies"
		public Keyword getImpliesKeyword_1_1() { return cImpliesKeyword_1_1; }
		
		//right=Xor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Xor
		public RuleCall getRightXorParserRuleCall_1_2_0() { return cRightXorParserRuleCall_1_2_0; }
	}
	public class XorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Xor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cXorLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cXorKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Xor Formula:
		//	Or ({Xor.left=current} "xor" right=Or)*
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({Xor.left=current} "xor" right=Or)*
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({Xor.left=current} "xor" right=Or)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Xor.left=current}
		public Action getXorLeftAction_1_0() { return cXorLeftAction_1_0; }
		
		//"xor"
		public Keyword getXorKeyword_1_1() { return cXorKeyword_1_1; }
		
		//right=Or
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Or
		public RuleCall getRightOrParserRuleCall_1_2_0() { return cRightOrParserRuleCall_1_2_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or Formula:
		//	And ({Or.left=current} "or" right=And)*
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.left=current} "or" right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.left=current} "or" right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//"or"
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBooleanExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBooleanExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And Formula:
		//	BooleanExpression ({And.left=current} "and" right=BooleanExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanExpression ({And.left=current} "and" right=BooleanExpression)*
		public Group getGroup() { return cGroup; }
		
		//BooleanExpression
		public RuleCall getBooleanExpressionParserRuleCall_0() { return cBooleanExpressionParserRuleCall_0; }
		
		//({And.left=current} "and" right=BooleanExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//"and"
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }
		
		//right=BooleanExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//BooleanExpression
		public RuleCall getRightBooleanExpressionParserRuleCall_1_2_0() { return cRightBooleanExpressionParserRuleCall_1_2_0; }
	}
	public class UnaryFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.UnaryFormula");
		private final RuleCall cNotParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// unary formulas:
		//UnaryFormula Formula:
		//	Not
		@Override public ParserRule getRule() { return rule; }
		
		//Not
		public RuleCall getNotParserRuleCall() { return cNotParserRuleCall; }
	}
	public class NotElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Not");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNotAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNotAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNotFormulaParserRuleCall_2_0 = (RuleCall)cNotAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Not UnaryFormula:
		//	{Not} "not(" not=Formula ")"
		@Override public ParserRule getRule() { return rule; }
		
		//{Not} "not(" not=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{Not}
		public Action getNotAction_0() { return cNotAction_0; }
		
		//"not("
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }
		
		//not=Formula
		public Assignment getNotAssignment_2() { return cNotAssignment_2; }
		
		//Formula
		public RuleCall getNotFormulaParserRuleCall_2_0() { return cNotFormulaParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class PredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Predicate");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEqualsParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cInequalityParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIsEmptyParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// predicates (term -> boolean):
		//Predicate Formula:
		//	Equals | Inequality | IsEmpty
		@Override public ParserRule getRule() { return rule; }
		
		//Equals | Inequality | IsEmpty
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Equals
		public RuleCall getEqualsParserRuleCall_0() { return cEqualsParserRuleCall_0; }
		
		//Inequality
		public RuleCall getInequalityParserRuleCall_1() { return cInequalityParserRuleCall_1; }
		
		//IsEmpty
		public RuleCall getIsEmptyParserRuleCall_2() { return cIsEmptyParserRuleCall_2; }
	}
	public class EqualsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Equals");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsEqualKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftTermParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightTermParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Equals:
		//	"isEqual(" left=Term "," right=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isEqual(" left=Term "," right=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isEqual("
		public Keyword getIsEqualKeyword_0() { return cIsEqualKeyword_0; }
		
		//left=Term
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_1_0() { return cLeftTermParserRuleCall_1_0; }
		
		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//right=Term
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_3_0() { return cRightTermParserRuleCall_3_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class InequalityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Inequality");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGreaterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cGreaterEqualParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSmallerParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSmallerEqualParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Inequality Formula:
		//	Greater | GreaterEqual | Smaller | SmallerEqual
		@Override public ParserRule getRule() { return rule; }
		
		//Greater | GreaterEqual | Smaller | SmallerEqual
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Greater
		public RuleCall getGreaterParserRuleCall_0() { return cGreaterParserRuleCall_0; }
		
		//GreaterEqual
		public RuleCall getGreaterEqualParserRuleCall_1() { return cGreaterEqualParserRuleCall_1; }
		
		//Smaller
		public RuleCall getSmallerParserRuleCall_2() { return cSmallerParserRuleCall_2; }
		
		//SmallerEqual
		public RuleCall getSmallerEqualParserRuleCall_3() { return cSmallerEqualParserRuleCall_3; }
	}
	public class GreaterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Greater");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsGreaterKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftTermParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightTermParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Greater:
		//	"isGreater(" left=Term "," right=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isGreater(" left=Term "," right=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isGreater("
		public Keyword getIsGreaterKeyword_0() { return cIsGreaterKeyword_0; }
		
		//left=Term
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_1_0() { return cLeftTermParserRuleCall_1_0; }
		
		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//right=Term
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_3_0() { return cRightTermParserRuleCall_3_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class GreaterEqualElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GreaterEqual");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsGreaterEqualKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftTermParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightTermParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//GreaterEqual:
		//	"isGreaterEqual(" left=Term "," right=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isGreaterEqual(" left=Term "," right=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isGreaterEqual("
		public Keyword getIsGreaterEqualKeyword_0() { return cIsGreaterEqualKeyword_0; }
		
		//left=Term
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_1_0() { return cLeftTermParserRuleCall_1_0; }
		
		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//right=Term
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_3_0() { return cRightTermParserRuleCall_3_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class SmallerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Smaller");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsSmallerKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftTermParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightTermParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Smaller:
		//	"isSmaller(" left=Term "," right=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isSmaller(" left=Term "," right=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isSmaller("
		public Keyword getIsSmallerKeyword_0() { return cIsSmallerKeyword_0; }
		
		//left=Term
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_1_0() { return cLeftTermParserRuleCall_1_0; }
		
		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//right=Term
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_3_0() { return cRightTermParserRuleCall_3_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class SmallerEqualElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.SmallerEqual");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsSmallerEqualKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLeftTermParserRuleCall_1_0 = (RuleCall)cLeftAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightTermParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SmallerEqual:
		//	"isSmallerEqual(" left=Term "," right=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isSmallerEqual(" left=Term "," right=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isSmallerEqual("
		public Keyword getIsSmallerEqualKeyword_0() { return cIsSmallerEqualKeyword_0; }
		
		//left=Term
		public Assignment getLeftAssignment_1() { return cLeftAssignment_1; }
		
		//Term
		public RuleCall getLeftTermParserRuleCall_1_0() { return cLeftTermParserRuleCall_1_0; }
		
		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//right=Term
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }
		
		//Term
		public RuleCall getRightTermParserRuleCall_3_0() { return cRightTermParserRuleCall_3_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class IsEmptyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.IsEmpty");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsEmptyKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTermAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTermTermParserRuleCall_1_0 = (RuleCall)cTermAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//IsEmpty:
		//	"isEmpty(" term=Term ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isEmpty(" term=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"isEmpty("
		public Keyword getIsEmptyKeyword_0() { return cIsEmptyKeyword_0; }
		
		//term=Term
		public Assignment getTermAssignment_1() { return cTermAssignment_1; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_1_0() { return cTermTermParserRuleCall_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class QuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Quantifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForAllParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExistsParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// TODO: infix inequality expressions
		////Greater returns Formula:
		////	GreaterEqual ({Greater.left=current} ">" right=GreaterEqual)*;
		////	
		////GreaterEqual returns Formula:
		////	Smaller ({GreaterEqual.left=current} ">=" right=Smaller)*;
		////
		////Smaller returns Formula:
		////	SmallerEqual ({Smaller.left=current} "<" right=SmallerEqual)*;
		////	
		////SmallerEqual returns Formula:
		////	Term ({SmallerEqual.left=current} "<=" right=Term)*;
		//// quantifier
		//Quantifier Formula:
		//	ForAll | Exists
		@Override public ParserRule getRule() { return rule; }
		
		//ForAll | Exists
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ForAll
		public RuleCall getForAllParserRuleCall_0() { return cForAllParserRuleCall_0; }
		
		//Exists
		public RuleCall getExistsParserRuleCall_1() { return cExistsParserRuleCall_1; }
	}
	public class ForAllElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.ForAll");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForAllAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cForAllKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameVariableParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIterationAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIterationTermParserRuleCall_4_0 = (RuleCall)cIterationAssignment_4.eContents().get(0);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cFormulaAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cFormulaFormulaParserRuleCall_6_0 = (RuleCall)cFormulaAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//ForAll Quantifier:
		//	{ForAll} "forAll(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		@Override public ParserRule getRule() { return rule; }
		
		//{ForAll} "forAll(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{ForAll}
		public Action getForAllAction_0() { return cForAllAction_0; }
		
		//"forAll("
		public Keyword getForAllKeyword_1() { return cForAllKeyword_1; }
		
		//name=Variable
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//Variable
		public RuleCall getNameVariableParserRuleCall_2_0() { return cNameVariableParserRuleCall_2_0; }
		
		//"in"
		public Keyword getInKeyword_3() { return cInKeyword_3; }
		
		//iteration=Term
		public Assignment getIterationAssignment_4() { return cIterationAssignment_4; }
		
		//Term
		public RuleCall getIterationTermParserRuleCall_4_0() { return cIterationTermParserRuleCall_4_0; }
		
		//":"
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_6() { return cFormulaAssignment_6; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_6_0() { return cFormulaFormulaParserRuleCall_6_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}
	public class ExistsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Exists");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExistsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cExistsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameVariableParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIterationAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIterationTermParserRuleCall_4_0 = (RuleCall)cIterationAssignment_4.eContents().get(0);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cFormulaAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cFormulaFormulaParserRuleCall_6_0 = (RuleCall)cFormulaAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//Exists Quantifier:
		//	{Exists} "exists(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		@Override public ParserRule getRule() { return rule; }
		
		//{Exists} "exists(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{Exists}
		public Action getExistsAction_0() { return cExistsAction_0; }
		
		//"exists("
		public Keyword getExistsKeyword_1() { return cExistsKeyword_1; }
		
		//name=Variable
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//Variable
		public RuleCall getNameVariableParserRuleCall_2_0() { return cNameVariableParserRuleCall_2_0; }
		
		//"in"
		public Keyword getInKeyword_3() { return cInKeyword_3; }
		
		//iteration=Term
		public Assignment getIterationAssignment_4() { return cIterationAssignment_4; }
		
		//Term
		public RuleCall getIterationTermParserRuleCall_4_0() { return cIterationTermParserRuleCall_4_0; }
		
		//":"
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_6() { return cFormulaAssignment_6; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_6_0() { return cFormulaFormulaParserRuleCall_6_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}
	public class BooleanExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.BooleanExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cFormulaParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cUnaryFormulaParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cQuantifierParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPredicateParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cBoolConstantParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//// boolean:
		//BooleanExpression Formula:
		//	'(' Formula ')' | UnaryFormula | Quantifier | Predicate | BoolConstant
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Formula ')' | UnaryFormula | Quantifier | Predicate | BoolConstant
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Formula ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Formula
		public RuleCall getFormulaParserRuleCall_0_1() { return cFormulaParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//UnaryFormula
		public RuleCall getUnaryFormulaParserRuleCall_1() { return cUnaryFormulaParserRuleCall_1; }
		
		//Quantifier
		public RuleCall getQuantifierParserRuleCall_2() { return cQuantifierParserRuleCall_2; }
		
		//Predicate
		public RuleCall getPredicateParserRuleCall_3() { return cPredicateParserRuleCall_3; }
		
		//BoolConstant
		public RuleCall getBoolConstantParserRuleCall_4() { return cBoolConstantParserRuleCall_4; }
	}
	public class BoolConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.BoolConstant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBoolConstantAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cValueAlternatives_1_0 = (Alternatives)cValueAssignment_1.eContents().get(0);
		private final Keyword cValueTrueKeyword_1_0_0 = (Keyword)cValueAlternatives_1_0.eContents().get(0);
		private final Keyword cValueFalseKeyword_1_0_1 = (Keyword)cValueAlternatives_1_0.eContents().get(1);
		
		//BoolConstant Term:
		//	{BoolConstant} value=('true' | 'false')
		@Override public ParserRule getRule() { return rule; }
		
		//{BoolConstant} value=('true' | 'false')
		public Group getGroup() { return cGroup; }
		
		//{BoolConstant}
		public Action getBoolConstantAction_0() { return cBoolConstantAction_0; }
		
		//value=('true' | 'false')
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//('true' | 'false')
		public Alternatives getValueAlternatives_1_0() { return cValueAlternatives_1_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_1_0_0() { return cValueTrueKeyword_1_0_0; }
		
		//'false'
		public Keyword getValueFalseKeyword_1_0_1() { return cValueFalseKeyword_1_0_1; }
	}
	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Term");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariableRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cGetContainmentParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cGetContainerParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// terms:
		//Term:
		//	Constant | VariableRef | GetContainment | GetContainer;
		@Override public ParserRule getRule() { return rule; }
		
		//Constant | VariableRef | GetContainment | GetContainer
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Constant
		public RuleCall getConstantParserRuleCall_0() { return cConstantParserRuleCall_0; }
		
		//VariableRef
		public RuleCall getVariableRefParserRuleCall_1() { return cVariableRefParserRuleCall_1; }
		
		//GetContainment
		public RuleCall getGetContainmentParserRuleCall_2() { return cGetContainmentParserRuleCall_2; }
		
		//GetContainer
		public RuleCall getGetContainerParserRuleCall_3() { return cGetContainerParserRuleCall_3; }
	}
	public class VariableRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.VariableRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableRefAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cNameVariableCrossReference_1_0 = (CrossReference)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameVariableIDTerminalRuleCall_1_0_1 = (RuleCall)cNameVariableCrossReference_1_0.eContents().get(1);
		private final Assignment cGetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cGetGetParserRuleCall_2_0 = (RuleCall)cGetAssignment_2.eContents().get(0);
		
		//VariableRef Term:
		//	{VariableRef} name=[Variable] get=Get?
		@Override public ParserRule getRule() { return rule; }
		
		//{VariableRef} name=[Variable] get=Get?
		public Group getGroup() { return cGroup; }
		
		//{VariableRef}
		public Action getVariableRefAction_0() { return cVariableRefAction_0; }
		
		//name=[Variable]
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//[Variable]
		public CrossReference getNameVariableCrossReference_1_0() { return cNameVariableCrossReference_1_0; }
		
		//ID
		public RuleCall getNameVariableIDTerminalRuleCall_1_0_1() { return cNameVariableIDTerminalRuleCall_1_0_1; }
		
		//get=Get?
		public Assignment getGetAssignment_2() { return cGetAssignment_2; }
		
		//Get
		public RuleCall getGetGetParserRuleCall_2_0() { return cGetGetParserRuleCall_2_0; }
	}
	public class GetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Get");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cTypeIDTerminalRuleCall_1_0_0 = (RuleCall)cTypeAssignment_1_0.eContents().get(0);
		private final Keyword cColonColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cNameEStructuralFeatureCrossReference_2_0 = (CrossReference)cNameAssignment_2.eContents().get(0);
		private final RuleCall cNameEStructuralFeatureIDTerminalRuleCall_2_0_1 = (RuleCall)cNameEStructuralFeatureCrossReference_2_0.eContents().get(1);
		private final Assignment cNextAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNextGetParserRuleCall_3_0 = (RuleCall)cNextAssignment_3.eContents().get(0);
		
		//Get:
		//	"." (type=ID "::")? name=[ecore::EStructuralFeature] next=Get?;
		@Override public ParserRule getRule() { return rule; }
		
		//"." (type=ID "::")? name=[ecore::EStructuralFeature] next=Get?
		public Group getGroup() { return cGroup; }
		
		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }
		
		//(type=ID "::")?
		public Group getGroup_1() { return cGroup_1; }
		
		//type=ID
		public Assignment getTypeAssignment_1_0() { return cTypeAssignment_1_0; }
		
		//ID
		public RuleCall getTypeIDTerminalRuleCall_1_0_0() { return cTypeIDTerminalRuleCall_1_0_0; }
		
		//"::"
		public Keyword getColonColonKeyword_1_1() { return cColonColonKeyword_1_1; }
		
		//name=[ecore::EStructuralFeature]
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//[ecore::EStructuralFeature]
		public CrossReference getNameEStructuralFeatureCrossReference_2_0() { return cNameEStructuralFeatureCrossReference_2_0; }
		
		//ID
		public RuleCall getNameEStructuralFeatureIDTerminalRuleCall_2_0_1() { return cNameEStructuralFeatureIDTerminalRuleCall_2_0_1; }
		
		//next=Get?
		public Assignment getNextAssignment_3() { return cNextAssignment_3; }
		
		//Get
		public RuleCall getNextGetParserRuleCall_3_0() { return cNextGetParserRuleCall_3_0; }
	}
	public class GetContainerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GetContainer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGetContainerKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cElementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementTermParserRuleCall_1_0 = (RuleCall)cElementAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//GetContainer Term:
		//	"getContainer(" element=Term ")"
		@Override public ParserRule getRule() { return rule; }
		
		//"getContainer(" element=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"getContainer("
		public Keyword getGetContainerKeyword_0() { return cGetContainerKeyword_0; }
		
		//element=Term
		public Assignment getElementAssignment_1() { return cElementAssignment_1; }
		
		//Term
		public RuleCall getElementTermParserRuleCall_1_0() { return cElementTermParserRuleCall_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class GetContainmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GetContainment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGetContainmentsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cElementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementTermParserRuleCall_1_0 = (RuleCall)cElementAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//GetContainment Term:
		//	"getContainments(" element=Term ")"
		@Override public ParserRule getRule() { return rule; }
		
		//"getContainments(" element=Term ")"
		public Group getGroup() { return cGroup; }
		
		//"getContainments("
		public Keyword getGetContainmentsKeyword_0() { return cGetContainmentsKeyword_0; }
		
		//element=Term
		public Assignment getElementAssignment_1() { return cElementAssignment_1; }
		
		//Term
		public RuleCall getElementTermParserRuleCall_1_0() { return cElementTermParserRuleCall_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cIntConstantAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cStringConstantAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final RuleCall cBoolConstantParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Constant Term:
		//	{IntConstant} value=INT | {StringConstant} value=STRING | BoolConstant
		@Override public ParserRule getRule() { return rule; }
		
		//{IntConstant} value=INT | {StringConstant} value=STRING | BoolConstant
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{IntConstant} value=INT
		public Group getGroup_0() { return cGroup_0; }
		
		//{IntConstant}
		public Action getIntConstantAction_0_0() { return cIntConstantAction_0_0; }
		
		//value=INT
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0_1_0() { return cValueINTTerminalRuleCall_0_1_0; }
		
		//{StringConstant} value=STRING
		public Group getGroup_1() { return cGroup_1; }
		
		//{StringConstant}
		public Action getStringConstantAction_1_0() { return cStringConstantAction_1_0; }
		
		//value=STRING
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_1_0() { return cValueSTRINGTerminalRuleCall_1_1_0; }
		
		//BoolConstant
		public RuleCall getBoolConstantParserRuleCall_2() { return cBoolConstantParserRuleCall_2; }
	}
	
	
	private final ConstraintLibraryElements pConstraintLibrary;
	private final ConstraintElements pConstraint;
	private final VariableElements pVariable;
	private final FormulaElements pFormula;
	private final BinaryFormulaElements pBinaryFormula;
	private final IffElements pIff;
	private final IfElements pIf;
	private final XorElements pXor;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final UnaryFormulaElements pUnaryFormula;
	private final NotElements pNot;
	private final PredicateElements pPredicate;
	private final EqualsElements pEquals;
	private final InequalityElements pInequality;
	private final GreaterElements pGreater;
	private final GreaterEqualElements pGreaterEqual;
	private final SmallerElements pSmaller;
	private final SmallerEqualElements pSmallerEqual;
	private final IsEmptyElements pIsEmpty;
	private final QuantifierElements pQuantifier;
	private final ForAllElements pForAll;
	private final ExistsElements pExists;
	private final BooleanExpressionElements pBooleanExpression;
	private final BoolConstantElements pBoolConstant;
	private final TermElements pTerm;
	private final VariableRefElements pVariableRef;
	private final GetElements pGet;
	private final GetContainerElements pGetContainer;
	private final GetContainmentElements pGetContainment;
	private final ConstantElements pConstant;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public FirstOrderLogicGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pConstraintLibrary = new ConstraintLibraryElements();
		this.pConstraint = new ConstraintElements();
		this.pVariable = new VariableElements();
		this.pFormula = new FormulaElements();
		this.pBinaryFormula = new BinaryFormulaElements();
		this.pIff = new IffElements();
		this.pIf = new IfElements();
		this.pXor = new XorElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pUnaryFormula = new UnaryFormulaElements();
		this.pNot = new NotElements();
		this.pPredicate = new PredicateElements();
		this.pEquals = new EqualsElements();
		this.pInequality = new InequalityElements();
		this.pGreater = new GreaterElements();
		this.pGreaterEqual = new GreaterEqualElements();
		this.pSmaller = new SmallerElements();
		this.pSmallerEqual = new SmallerEqualElements();
		this.pIsEmpty = new IsEmptyElements();
		this.pQuantifier = new QuantifierElements();
		this.pForAll = new ForAllElements();
		this.pExists = new ExistsElements();
		this.pBooleanExpression = new BooleanExpressionElements();
		this.pBoolConstant = new BoolConstantElements();
		this.pTerm = new TermElements();
		this.pVariableRef = new VariableRefElements();
		this.pGet = new GetElements();
		this.pGetContainer = new GetContainerElements();
		this.pGetContainment = new GetContainmentElements();
		this.pConstant = new ConstantElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.sidiff.validation.laguage.fol.FirstOrderLogic".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// NOTE: escape keywords with ^keyword
	//ConstraintLibrary:
	//	"domain" domain=STRING 'import' packageImport=STRING
	//	constraints+=Constraint*;
	public ConstraintLibraryElements getConstraintLibraryAccess() {
		return pConstraintLibrary;
	}
	
	public ParserRule getConstraintLibraryRule() {
		return getConstraintLibraryAccess().getRule();
	}
	
	//Constraint:
	//	'constraint' name=ID 'message' message=STRING 'context' variable=Variable ':' formula=Formula;
	public ConstraintElements getConstraintAccess() {
		return pConstraint;
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}
	
	//Variable:
	//	type=ID name=ID;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//// formula:
	/// * 
	// * Precedence: not, and, or, xor, if/implies, iff
	// * 
	// * To define the precedence we must write the rule for the operator with less precedence in 
	// * terms of the rule for the operator with higher precedence. This means that in the grammar, 
	// * the rules for operators with less precedence are defined first.
	// * / // binary formulas:
	//// TODO: How to make If, Xor,... inherit from BinaryFormula?
	//// http://www.lorenzobettini.it/2014/02/switching-from-an-inferred-ecore-model-to-an-imported-one-in-your-xtext-grammar/
	//Formula:
	//	BinaryFormula;
	public FormulaElements getFormulaAccess() {
		return pFormula;
	}
	
	public ParserRule getFormulaRule() {
		return getFormulaAccess().getRule();
	}
	
	//BinaryFormula Formula:
	//	Iff
	public BinaryFormulaElements getBinaryFormulaAccess() {
		return pBinaryFormula;
	}
	
	public ParserRule getBinaryFormulaRule() {
		return getBinaryFormulaAccess().getRule();
	}
	
	//Iff Formula:
	//	If ({Iff.left=current} "=" right=If)*
	public IffElements getIffAccess() {
		return pIff;
	}
	
	public ParserRule getIffRule() {
		return getIffAccess().getRule();
	}
	
	//If Formula:
	//	Xor ({If.left=current} "implies" right=Xor)*
	public IfElements getIfAccess() {
		return pIf;
	}
	
	public ParserRule getIfRule() {
		return getIfAccess().getRule();
	}
	
	//Xor Formula:
	//	Or ({Xor.left=current} "xor" right=Or)*
	public XorElements getXorAccess() {
		return pXor;
	}
	
	public ParserRule getXorRule() {
		return getXorAccess().getRule();
	}
	
	//Or Formula:
	//	And ({Or.left=current} "or" right=And)*
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Formula:
	//	BooleanExpression ({And.left=current} "and" right=BooleanExpression)*
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//// unary formulas:
	//UnaryFormula Formula:
	//	Not
	public UnaryFormulaElements getUnaryFormulaAccess() {
		return pUnaryFormula;
	}
	
	public ParserRule getUnaryFormulaRule() {
		return getUnaryFormulaAccess().getRule();
	}
	
	//Not UnaryFormula:
	//	{Not} "not(" not=Formula ")"
	public NotElements getNotAccess() {
		return pNot;
	}
	
	public ParserRule getNotRule() {
		return getNotAccess().getRule();
	}
	
	//// predicates (term -> boolean):
	//Predicate Formula:
	//	Equals | Inequality | IsEmpty
	public PredicateElements getPredicateAccess() {
		return pPredicate;
	}
	
	public ParserRule getPredicateRule() {
		return getPredicateAccess().getRule();
	}
	
	//Equals:
	//	"isEqual(" left=Term "," right=Term ")";
	public EqualsElements getEqualsAccess() {
		return pEquals;
	}
	
	public ParserRule getEqualsRule() {
		return getEqualsAccess().getRule();
	}
	
	//Inequality Formula:
	//	Greater | GreaterEqual | Smaller | SmallerEqual
	public InequalityElements getInequalityAccess() {
		return pInequality;
	}
	
	public ParserRule getInequalityRule() {
		return getInequalityAccess().getRule();
	}
	
	//Greater:
	//	"isGreater(" left=Term "," right=Term ")";
	public GreaterElements getGreaterAccess() {
		return pGreater;
	}
	
	public ParserRule getGreaterRule() {
		return getGreaterAccess().getRule();
	}
	
	//GreaterEqual:
	//	"isGreaterEqual(" left=Term "," right=Term ")";
	public GreaterEqualElements getGreaterEqualAccess() {
		return pGreaterEqual;
	}
	
	public ParserRule getGreaterEqualRule() {
		return getGreaterEqualAccess().getRule();
	}
	
	//Smaller:
	//	"isSmaller(" left=Term "," right=Term ")";
	public SmallerElements getSmallerAccess() {
		return pSmaller;
	}
	
	public ParserRule getSmallerRule() {
		return getSmallerAccess().getRule();
	}
	
	//SmallerEqual:
	//	"isSmallerEqual(" left=Term "," right=Term ")";
	public SmallerEqualElements getSmallerEqualAccess() {
		return pSmallerEqual;
	}
	
	public ParserRule getSmallerEqualRule() {
		return getSmallerEqualAccess().getRule();
	}
	
	//IsEmpty:
	//	"isEmpty(" term=Term ")";
	public IsEmptyElements getIsEmptyAccess() {
		return pIsEmpty;
	}
	
	public ParserRule getIsEmptyRule() {
		return getIsEmptyAccess().getRule();
	}
	
	//// TODO: infix inequality expressions
	////Greater returns Formula:
	////	GreaterEqual ({Greater.left=current} ">" right=GreaterEqual)*;
	////	
	////GreaterEqual returns Formula:
	////	Smaller ({GreaterEqual.left=current} ">=" right=Smaller)*;
	////
	////Smaller returns Formula:
	////	SmallerEqual ({Smaller.left=current} "<" right=SmallerEqual)*;
	////	
	////SmallerEqual returns Formula:
	////	Term ({SmallerEqual.left=current} "<=" right=Term)*;
	//// quantifier
	//Quantifier Formula:
	//	ForAll | Exists
	public QuantifierElements getQuantifierAccess() {
		return pQuantifier;
	}
	
	public ParserRule getQuantifierRule() {
		return getQuantifierAccess().getRule();
	}
	
	//ForAll Quantifier:
	//	{ForAll} "forAll(" name=Variable "in" iteration=Term ":" formula=Formula ")"
	public ForAllElements getForAllAccess() {
		return pForAll;
	}
	
	public ParserRule getForAllRule() {
		return getForAllAccess().getRule();
	}
	
	//Exists Quantifier:
	//	{Exists} "exists(" name=Variable "in" iteration=Term ":" formula=Formula ")"
	public ExistsElements getExistsAccess() {
		return pExists;
	}
	
	public ParserRule getExistsRule() {
		return getExistsAccess().getRule();
	}
	
	//// boolean:
	//BooleanExpression Formula:
	//	'(' Formula ')' | UnaryFormula | Quantifier | Predicate | BoolConstant
	public BooleanExpressionElements getBooleanExpressionAccess() {
		return pBooleanExpression;
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}
	
	//BoolConstant Term:
	//	{BoolConstant} value=('true' | 'false')
	public BoolConstantElements getBoolConstantAccess() {
		return pBoolConstant;
	}
	
	public ParserRule getBoolConstantRule() {
		return getBoolConstantAccess().getRule();
	}
	
	//// terms:
	//Term:
	//	Constant | VariableRef | GetContainment | GetContainer;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}
	
	//VariableRef Term:
	//	{VariableRef} name=[Variable] get=Get?
	public VariableRefElements getVariableRefAccess() {
		return pVariableRef;
	}
	
	public ParserRule getVariableRefRule() {
		return getVariableRefAccess().getRule();
	}
	
	//Get:
	//	"." (type=ID "::")? name=[ecore::EStructuralFeature] next=Get?;
	public GetElements getGetAccess() {
		return pGet;
	}
	
	public ParserRule getGetRule() {
		return getGetAccess().getRule();
	}
	
	//GetContainer Term:
	//	"getContainer(" element=Term ")"
	public GetContainerElements getGetContainerAccess() {
		return pGetContainer;
	}
	
	public ParserRule getGetContainerRule() {
		return getGetContainerAccess().getRule();
	}
	
	//GetContainment Term:
	//	"getContainments(" element=Term ")"
	public GetContainmentElements getGetContainmentAccess() {
		return pGetContainment;
	}
	
	public ParserRule getGetContainmentRule() {
		return getGetContainmentAccess().getRule();
	}
	
	//Constant Term:
	//	{IntConstant} value=INT | {StringConstant} value=STRING | BoolConstant
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
