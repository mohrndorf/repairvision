/*
 * generated by Xtext 2.10.0
 */
package org.sidiff.validation.laguage.fol.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class FirstOrderLogicGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ConstraintRuleBaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.ConstraintRuleBase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDomainKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDomainAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDomainSTRINGTerminalRuleCall_1_0 = (RuleCall)cDomainAssignment_1.eContents().get(0);
		private final Assignment cConstraintsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConstraintsConstraintParserRuleCall_2_0 = (RuleCall)cConstraintsAssignment_2.eContents().get(0);
		
		//ConstraintRuleBase:
		//	"domain" domain=STRING
		//	constraints+=Constraint;
		@Override public ParserRule getRule() { return rule; }
		
		//"domain" domain=STRING constraints+=Constraint
		public Group getGroup() { return cGroup; }
		
		//"domain"
		public Keyword getDomainKeyword_0() { return cDomainKeyword_0; }
		
		//domain=STRING
		public Assignment getDomainAssignment_1() { return cDomainAssignment_1; }
		
		//STRING
		public RuleCall getDomainSTRINGTerminalRuleCall_1_0() { return cDomainSTRINGTerminalRuleCall_1_0; }
		
		//constraints+=Constraint
		public Assignment getConstraintsAssignment_2() { return cConstraintsAssignment_2; }
		
		//Constraint
		public RuleCall getConstraintsConstraintParserRuleCall_2_0() { return cConstraintsConstraintParserRuleCall_2_0; }
	}
	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Constraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cContextKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableVariableParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cFormulaAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFormulaFormulaParserRuleCall_3_0 = (RuleCall)cFormulaAssignment_3.eContents().get(0);
		
		//Constraint:
		//	'context' variable=Variable ':' formula=Formula;
		@Override public ParserRule getRule() { return rule; }
		
		//'context' variable=Variable ':' formula=Formula
		public Group getGroup() { return cGroup; }
		
		//'context'
		public Keyword getContextKeyword_0() { return cContextKeyword_0; }
		
		//variable=Variable
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//Variable
		public RuleCall getVariableVariableParserRuleCall_1_0() { return cVariableVariableParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_3() { return cFormulaAssignment_3; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_3_0() { return cFormulaFormulaParserRuleCall_3_0; }
	}
	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Term");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFunctionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// terms:
		//Term:
		//	Variable | Function;
		@Override public ParserRule getRule() { return rule; }
		
		//Variable | Function
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Variable
		public RuleCall getVariableParserRuleCall_0() { return cVariableParserRuleCall_0; }
		
		//Function
		public RuleCall getFunctionParserRuleCall_1() { return cFunctionParserRuleCall_1; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeIDTerminalRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Variable:
		//	type=ID name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=ID name=ID
		public Group getGroup() { return cGroup; }
		
		//type=ID
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//ID
		public RuleCall getTypeIDTerminalRuleCall_0_0() { return cTypeIDTerminalRuleCall_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Function");
		private final RuleCall cGetTermParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Function Term:
		//	GetTerm
		@Override public ParserRule getRule() { return rule; }
		
		////	Get
		// GetTerm
		public RuleCall getGetTermParserRuleCall() { return cGetTermParserRuleCall; }
	}
	public class GetTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GetTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGetTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cNameVariableCrossReference_1_0 = (CrossReference)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameVariableIDTerminalRuleCall_1_0_1 = (RuleCall)cNameVariableCrossReference_1_0.eContents().get(1);
		private final Assignment cFeatureAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFeatureGetParserRuleCall_2_0 = (RuleCall)cFeatureAssignment_2.eContents().get(0);
		
		//GetTerm Term:
		//	{GetTerm} name=[Variable] feature=Get?
		@Override public ParserRule getRule() { return rule; }
		
		//{GetTerm} name=[Variable] feature=Get?
		public Group getGroup() { return cGroup; }
		
		//{GetTerm}
		public Action getGetTermAction_0() { return cGetTermAction_0; }
		
		//name=[Variable]
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//[Variable]
		public CrossReference getNameVariableCrossReference_1_0() { return cNameVariableCrossReference_1_0; }
		
		//ID
		public RuleCall getNameVariableIDTerminalRuleCall_1_0_1() { return cNameVariableIDTerminalRuleCall_1_0_1; }
		
		//feature=Get?
		public Assignment getFeatureAssignment_2() { return cFeatureAssignment_2; }
		
		//Get
		public RuleCall getFeatureGetParserRuleCall_2_0() { return cFeatureGetParserRuleCall_2_0; }
	}
	public class GetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Get");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cTypeIDTerminalRuleCall_1_0_0 = (RuleCall)cTypeAssignment_1_0.eContents().get(0);
		private final Keyword cColonColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cNameEStructuralFeatureCrossReference_2_0 = (CrossReference)cNameAssignment_2.eContents().get(0);
		private final RuleCall cNameEStructuralFeatureFeatureParserRuleCall_2_0_1 = (RuleCall)cNameEStructuralFeatureCrossReference_2_0.eContents().get(1);
		private final Assignment cNextAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNextGetParserRuleCall_3_0 = (RuleCall)cNextAssignment_3.eContents().get(0);
		
		//Get:
		//	"." (type=ID "::")? name=[ecore::EStructuralFeature|Feature] next=Get?;
		@Override public ParserRule getRule() { return rule; }
		
		//"." (type=ID "::")? name=[ecore::EStructuralFeature|Feature] next=Get?
		public Group getGroup() { return cGroup; }
		
		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }
		
		//(type=ID "::")?
		public Group getGroup_1() { return cGroup_1; }
		
		//type=ID
		public Assignment getTypeAssignment_1_0() { return cTypeAssignment_1_0; }
		
		//ID
		public RuleCall getTypeIDTerminalRuleCall_1_0_0() { return cTypeIDTerminalRuleCall_1_0_0; }
		
		//"::"
		public Keyword getColonColonKeyword_1_1() { return cColonColonKeyword_1_1; }
		
		//name=[ecore::EStructuralFeature|Feature]
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//[ecore::EStructuralFeature|Feature]
		public CrossReference getNameEStructuralFeatureCrossReference_2_0() { return cNameEStructuralFeatureCrossReference_2_0; }
		
		//Feature
		public RuleCall getNameEStructuralFeatureFeatureParserRuleCall_2_0_1() { return cNameEStructuralFeatureFeatureParserRuleCall_2_0_1; }
		
		//next=Get?
		public Assignment getNextAssignment_3() { return cNextAssignment_3; }
		
		//Get
		public RuleCall getNextGetParserRuleCall_3_0() { return cNextGetParserRuleCall_3_0; }
	}
	public class FeatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Feature");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		////Get returns Term:
		// //	Variable ({Get.context=current} "." feature=[ecore::EStructuralFeature|Feature])*;
		////  Variable ({Get.context=current} "." feature=ID)*;
		//Feature:
		//	ID;
		@Override public ParserRule getRule() { return rule; }
		
		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}
	public class FormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Formula");
		private final RuleCall cEqualityParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// equality:
		//Formula:
		//	Equality;
		@Override public ParserRule getRule() { return rule; }
		
		//Equality
		public RuleCall getEqualityParserRuleCall() { return cEqualityParserRuleCall; }
	}
	public class EqualityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Equality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBinaryFormulaParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualityLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBinaryFormulaParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Equality Formula:
		//	BinaryFormula ({Equality.left=current} "=" right=BinaryFormula)*
		@Override public ParserRule getRule() { return rule; }
		
		//BinaryFormula ({Equality.left=current} "=" right=BinaryFormula)*
		public Group getGroup() { return cGroup; }
		
		//BinaryFormula
		public RuleCall getBinaryFormulaParserRuleCall_0() { return cBinaryFormulaParserRuleCall_0; }
		
		//({Equality.left=current} "=" right=BinaryFormula)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Equality.left=current}
		public Action getEqualityLeftAction_1_0() { return cEqualityLeftAction_1_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }
		
		//right=BinaryFormula
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//BinaryFormula
		public RuleCall getRightBinaryFormulaParserRuleCall_1_2_0() { return cRightBinaryFormulaParserRuleCall_1_2_0; }
	}
	public class BinaryFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.BinaryFormula");
		private final RuleCall cIfParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * 
		// * Precedence: not, and, or, xor, if
		// * 
		// * To define the precedence we must write the rule for the operator with less precedence in 
		// * terms of the rule for the operator with higher precedence. This means that in the grammar, 
		// * the rules for operators with less precedence are defined first.
		// * / // binary formulas:
		//// TODO: How to make If, Xor,... inherit from BinaryFormula?
		//// http://www.lorenzobettini.it/2014/02/switching-from-an-inferred-ecore-model-to-an-imported-one-in-your-xtext-grammar/
		//BinaryFormula Formula:
		//	If
		@Override public ParserRule getRule() { return rule; }
		
		//If
		public RuleCall getIfParserRuleCall() { return cIfParserRuleCall; }
	}
	public class IfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.If");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIfLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cImpliesKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//If Formula:
		//	Xor ({If.left=current} "implies" right=Xor)*
		@Override public ParserRule getRule() { return rule; }
		
		//Xor ({If.left=current} "implies" right=Xor)*
		public Group getGroup() { return cGroup; }
		
		//Xor
		public RuleCall getXorParserRuleCall_0() { return cXorParserRuleCall_0; }
		
		//({If.left=current} "implies" right=Xor)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{If.left=current}
		public Action getIfLeftAction_1_0() { return cIfLeftAction_1_0; }
		
		//"implies"
		public Keyword getImpliesKeyword_1_1() { return cImpliesKeyword_1_1; }
		
		//right=Xor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Xor
		public RuleCall getRightXorParserRuleCall_1_2_0() { return cRightXorParserRuleCall_1_2_0; }
	}
	public class XorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Xor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cXorLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cXorKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Xor Formula:
		//	Or ({Xor.left=current} "xor" right=Or)*
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({Xor.left=current} "xor" right=Or)*
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({Xor.left=current} "xor" right=Or)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Xor.left=current}
		public Action getXorLeftAction_1_0() { return cXorLeftAction_1_0; }
		
		//"xor"
		public Keyword getXorKeyword_1_1() { return cXorKeyword_1_1; }
		
		//right=Or
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Or
		public RuleCall getRightOrParserRuleCall_1_2_0() { return cRightOrParserRuleCall_1_2_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or Formula:
		//	And ({Or.left=current} "or" right=And)*
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.left=current} "or" right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.left=current} "or" right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//"or"
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cGreaterParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightGreaterParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And Formula:
		//	Greater ({And.left=current} "and" right=Greater)*
		@Override public ParserRule getRule() { return rule; }
		
		//Greater ({And.left=current} "and" right=Greater)*
		public Group getGroup() { return cGroup; }
		
		//Greater
		public RuleCall getGreaterParserRuleCall_0() { return cGreaterParserRuleCall_0; }
		
		//({And.left=current} "and" right=Greater)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//"and"
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }
		
		//right=Greater
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Greater
		public RuleCall getRightGreaterParserRuleCall_1_2_0() { return cRightGreaterParserRuleCall_1_2_0; }
	}
	public class UnaryFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.UnaryFormula");
		private final RuleCall cNotParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// unary formulas:
		//UnaryFormula Formula:
		//	Not
		@Override public ParserRule getRule() { return rule; }
		
		//Not
		public RuleCall getNotParserRuleCall() { return cNotParserRuleCall; }
	}
	public class NotElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Not");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNotAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNotAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNotFormulaParserRuleCall_2_0 = (RuleCall)cNotAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Not UnaryFormula:
		//	{Not} "not(" not=Formula ")"
		@Override public ParserRule getRule() { return rule; }
		
		//{Not} "not(" not=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{Not}
		public Action getNotAction_0() { return cNotAction_0; }
		
		//"not("
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }
		
		//not=Formula
		public Assignment getNotAssignment_2() { return cNotAssignment_2; }
		
		//Formula
		public RuleCall getNotFormulaParserRuleCall_2_0() { return cNotFormulaParserRuleCall_2_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class PredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Predicate");
		private final RuleCall cIsEmptyParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// predicates (term -> boolean):
		//Predicate Formula:
		//	IsEmpty
		@Override public ParserRule getRule() { return rule; }
		
		//IsEmpty
		public RuleCall getIsEmptyParserRuleCall() { return cIsEmptyParserRuleCall; }
	}
	public class IsEmptyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.IsEmpty");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIsEmptyKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTermAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTermTermCrossReference_1_0 = (CrossReference)cTermAssignment_1.eContents().get(0);
		private final RuleCall cTermTermIDTerminalRuleCall_1_0_1 = (RuleCall)cTermTermCrossReference_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//IsEmpty:
		//	"isEmpty(" term=[Term] ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"isEmpty(" term=[Term] ")"
		public Group getGroup() { return cGroup; }
		
		//"isEmpty("
		public Keyword getIsEmptyKeyword_0() { return cIsEmptyKeyword_0; }
		
		//term=[Term]
		public Assignment getTermAssignment_1() { return cTermAssignment_1; }
		
		//[Term]
		public CrossReference getTermTermCrossReference_1_0() { return cTermTermCrossReference_1_0; }
		
		//ID
		public RuleCall getTermTermIDTerminalRuleCall_1_0_1() { return cTermTermIDTerminalRuleCall_1_0_1; }
		
		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class GreaterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Greater");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cGreaterEqualParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cGreaterLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightGreaterEqualParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// TODO: left/right should be of type Term
		//Greater Formula:
		//	GreaterEqual ({Greater.left=current} ">" right=GreaterEqual)*
		@Override public ParserRule getRule() { return rule; }
		
		//GreaterEqual ({Greater.left=current} ">" right=GreaterEqual)*
		public Group getGroup() { return cGroup; }
		
		//GreaterEqual
		public RuleCall getGreaterEqualParserRuleCall_0() { return cGreaterEqualParserRuleCall_0; }
		
		//({Greater.left=current} ">" right=GreaterEqual)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Greater.left=current}
		public Action getGreaterLeftAction_1_0() { return cGreaterLeftAction_1_0; }
		
		//">"
		public Keyword getGreaterThanSignKeyword_1_1() { return cGreaterThanSignKeyword_1_1; }
		
		//right=GreaterEqual
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//GreaterEqual
		public RuleCall getRightGreaterEqualParserRuleCall_1_2_0() { return cRightGreaterEqualParserRuleCall_1_2_0; }
	}
	public class GreaterEqualElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.GreaterEqual");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSmallerParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cGreaterEqualLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSmallerParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//GreaterEqual Formula:
		//	Smaller ({GreaterEqual.left=current} ">=" right=Smaller)*
		@Override public ParserRule getRule() { return rule; }
		
		//Smaller ({GreaterEqual.left=current} ">=" right=Smaller)*
		public Group getGroup() { return cGroup; }
		
		//Smaller
		public RuleCall getSmallerParserRuleCall_0() { return cSmallerParserRuleCall_0; }
		
		//({GreaterEqual.left=current} ">=" right=Smaller)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{GreaterEqual.left=current}
		public Action getGreaterEqualLeftAction_1_0() { return cGreaterEqualLeftAction_1_0; }
		
		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_1() { return cGreaterThanSignEqualsSignKeyword_1_1; }
		
		//right=Smaller
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Smaller
		public RuleCall getRightSmallerParserRuleCall_1_2_0() { return cRightSmallerParserRuleCall_1_2_0; }
	}
	public class SmallerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Smaller");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSmallerEqualParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSmallerLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSmallerEqualParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Smaller Formula:
		//	SmallerEqual ({Smaller.left=current} "<" right=SmallerEqual)*
		@Override public ParserRule getRule() { return rule; }
		
		//SmallerEqual ({Smaller.left=current} "<" right=SmallerEqual)*
		public Group getGroup() { return cGroup; }
		
		//SmallerEqual
		public RuleCall getSmallerEqualParserRuleCall_0() { return cSmallerEqualParserRuleCall_0; }
		
		//({Smaller.left=current} "<" right=SmallerEqual)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Smaller.left=current}
		public Action getSmallerLeftAction_1_0() { return cSmallerLeftAction_1_0; }
		
		//"<"
		public Keyword getLessThanSignKeyword_1_1() { return cLessThanSignKeyword_1_1; }
		
		//right=SmallerEqual
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//SmallerEqual
		public RuleCall getRightSmallerEqualParserRuleCall_1_2_0() { return cRightSmallerEqualParserRuleCall_1_2_0; }
	}
	public class SmallerEqualElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.SmallerEqual");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSmallerEqualLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//SmallerEqual Formula:
		//	Primary ({SmallerEqual.left=current} "<=" right=Primary)*
		@Override public ParserRule getRule() { return rule; }
		
		//Primary ({SmallerEqual.left=current} "<=" right=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//({SmallerEqual.left=current} "<=" right=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{SmallerEqual.left=current}
		public Action getSmallerEqualLeftAction_1_0() { return cSmallerEqualLeftAction_1_0; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_1() { return cLessThanSignEqualsSignKeyword_1_1; }
		
		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}
	public class QuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Quantifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForAllParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExistsParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// quantifier
		//Quantifier Formula:
		//	ForAll | Exists
		@Override public ParserRule getRule() { return rule; }
		
		//ForAll | Exists
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ForAll
		public RuleCall getForAllParserRuleCall_0() { return cForAllParserRuleCall_0; }
		
		//Exists
		public RuleCall getExistsParserRuleCall_1() { return cExistsParserRuleCall_1; }
	}
	public class ForAllElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.ForAll");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForAllAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cForAllKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameVariableParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIterationAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIterationTermParserRuleCall_4_0 = (RuleCall)cIterationAssignment_4.eContents().get(0);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cFormulaAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cFormulaFormulaParserRuleCall_6_0 = (RuleCall)cFormulaAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//ForAll Quantifier:
		//	{ForAll} "forAll(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		@Override public ParserRule getRule() { return rule; }
		
		//{ForAll} "forAll(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{ForAll}
		public Action getForAllAction_0() { return cForAllAction_0; }
		
		//"forAll("
		public Keyword getForAllKeyword_1() { return cForAllKeyword_1; }
		
		//name=Variable
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//Variable
		public RuleCall getNameVariableParserRuleCall_2_0() { return cNameVariableParserRuleCall_2_0; }
		
		//"in"
		public Keyword getInKeyword_3() { return cInKeyword_3; }
		
		//iteration=Term
		public Assignment getIterationAssignment_4() { return cIterationAssignment_4; }
		
		//Term
		public RuleCall getIterationTermParserRuleCall_4_0() { return cIterationTermParserRuleCall_4_0; }
		
		//":"
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_6() { return cFormulaAssignment_6; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_6_0() { return cFormulaFormulaParserRuleCall_6_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}
	public class ExistsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Exists");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExistsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cExistsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameVariableParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIterationAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIterationTermParserRuleCall_4_0 = (RuleCall)cIterationAssignment_4.eContents().get(0);
		private final Keyword cColonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cFormulaAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cFormulaFormulaParserRuleCall_6_0 = (RuleCall)cFormulaAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//Exists Quantifier:
		//	{Exists} "exists(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		@Override public ParserRule getRule() { return rule; }
		
		//{Exists} "exists(" name=Variable "in" iteration=Term ":" formula=Formula ")"
		public Group getGroup() { return cGroup; }
		
		//{Exists}
		public Action getExistsAction_0() { return cExistsAction_0; }
		
		//"exists("
		public Keyword getExistsKeyword_1() { return cExistsKeyword_1; }
		
		//name=Variable
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//Variable
		public RuleCall getNameVariableParserRuleCall_2_0() { return cNameVariableParserRuleCall_2_0; }
		
		//"in"
		public Keyword getInKeyword_3() { return cInKeyword_3; }
		
		//iteration=Term
		public Assignment getIterationAssignment_4() { return cIterationAssignment_4; }
		
		//Term
		public RuleCall getIterationTermParserRuleCall_4_0() { return cIterationTermParserRuleCall_4_0; }
		
		//":"
		public Keyword getColonKeyword_5() { return cColonKeyword_5; }
		
		//formula=Formula
		public Assignment getFormulaAssignment_6() { return cFormulaAssignment_6; }
		
		//Formula
		public RuleCall getFormulaFormulaParserRuleCall_6_0() { return cFormulaFormulaParserRuleCall_6_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cFormulaParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cUnaryFormulaParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cQuantifierParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPredicateParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cConstantParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//// general:
		//Primary Formula:
		//	'(' Formula ')' | UnaryFormula | Quantifier | Predicate | Constant
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Formula ')' | UnaryFormula | Quantifier | Predicate | Constant
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Formula ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Formula
		public RuleCall getFormulaParserRuleCall_0_1() { return cFormulaParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//UnaryFormula
		public RuleCall getUnaryFormulaParserRuleCall_1() { return cUnaryFormulaParserRuleCall_1; }
		
		//Quantifier
		public RuleCall getQuantifierParserRuleCall_2() { return cQuantifierParserRuleCall_2; }
		
		//Predicate
		public RuleCall getPredicateParserRuleCall_3() { return cPredicateParserRuleCall_3; }
		
		//Constant
		public RuleCall getConstantParserRuleCall_4() { return cConstantParserRuleCall_4; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.sidiff.validation.laguage.fol.FirstOrderLogic.Constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cIntConstantAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cStringConstantAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cBoolConstantAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final Alternatives cValueAlternatives_2_1_0 = (Alternatives)cValueAssignment_2_1.eContents().get(0);
		private final Keyword cValueTrueKeyword_2_1_0_0 = (Keyword)cValueAlternatives_2_1_0.eContents().get(0);
		private final Keyword cValueFalseKeyword_2_1_0_1 = (Keyword)cValueAlternatives_2_1_0.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cVariableRefAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cVariableAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cVariableVariableCrossReference_3_1_0 = (CrossReference)cVariableAssignment_3_1.eContents().get(0);
		private final RuleCall cVariableVariableIDTerminalRuleCall_3_1_0_1 = (RuleCall)cVariableVariableCrossReference_3_1_0.eContents().get(1);
		
		//Constant Term:
		//	{IntConstant} value=INT | {StringConstant} value=STRING | {BoolConstant} value=('true' | 'false') | {VariableRef}
		//	variable=[Variable]
		@Override public ParserRule getRule() { return rule; }
		
		//{IntConstant} value=INT | {StringConstant} value=STRING | {BoolConstant} value=('true' | 'false') | {VariableRef}
		//variable=[Variable]
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{IntConstant} value=INT
		public Group getGroup_0() { return cGroup_0; }
		
		//{IntConstant}
		public Action getIntConstantAction_0_0() { return cIntConstantAction_0_0; }
		
		//value=INT
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0_1_0() { return cValueINTTerminalRuleCall_0_1_0; }
		
		//{StringConstant} value=STRING
		public Group getGroup_1() { return cGroup_1; }
		
		//{StringConstant}
		public Action getStringConstantAction_1_0() { return cStringConstantAction_1_0; }
		
		//value=STRING
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_1_0() { return cValueSTRINGTerminalRuleCall_1_1_0; }
		
		//{BoolConstant} value=('true' | 'false')
		public Group getGroup_2() { return cGroup_2; }
		
		//{BoolConstant}
		public Action getBoolConstantAction_2_0() { return cBoolConstantAction_2_0; }
		
		//value=('true' | 'false')
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//('true' | 'false')
		public Alternatives getValueAlternatives_2_1_0() { return cValueAlternatives_2_1_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_2_1_0_0() { return cValueTrueKeyword_2_1_0_0; }
		
		//'false'
		public Keyword getValueFalseKeyword_2_1_0_1() { return cValueFalseKeyword_2_1_0_1; }
		
		//{VariableRef} variable=[Variable]
		public Group getGroup_3() { return cGroup_3; }
		
		//{VariableRef}
		public Action getVariableRefAction_3_0() { return cVariableRefAction_3_0; }
		
		//variable=[Variable]
		public Assignment getVariableAssignment_3_1() { return cVariableAssignment_3_1; }
		
		//[Variable]
		public CrossReference getVariableVariableCrossReference_3_1_0() { return cVariableVariableCrossReference_3_1_0; }
		
		//ID
		public RuleCall getVariableVariableIDTerminalRuleCall_3_1_0_1() { return cVariableVariableIDTerminalRuleCall_3_1_0_1; }
	}
	
	
	private final ConstraintRuleBaseElements pConstraintRuleBase;
	private final ConstraintElements pConstraint;
	private final TermElements pTerm;
	private final VariableElements pVariable;
	private final FunctionElements pFunction;
	private final GetTermElements pGetTerm;
	private final GetElements pGet;
	private final FeatureElements pFeature;
	private final FormulaElements pFormula;
	private final EqualityElements pEquality;
	private final BinaryFormulaElements pBinaryFormula;
	private final IfElements pIf;
	private final XorElements pXor;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final UnaryFormulaElements pUnaryFormula;
	private final NotElements pNot;
	private final PredicateElements pPredicate;
	private final IsEmptyElements pIsEmpty;
	private final GreaterElements pGreater;
	private final GreaterEqualElements pGreaterEqual;
	private final SmallerElements pSmaller;
	private final SmallerEqualElements pSmallerEqual;
	private final QuantifierElements pQuantifier;
	private final ForAllElements pForAll;
	private final ExistsElements pExists;
	private final PrimaryElements pPrimary;
	private final ConstantElements pConstant;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public FirstOrderLogicGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pConstraintRuleBase = new ConstraintRuleBaseElements();
		this.pConstraint = new ConstraintElements();
		this.pTerm = new TermElements();
		this.pVariable = new VariableElements();
		this.pFunction = new FunctionElements();
		this.pGetTerm = new GetTermElements();
		this.pGet = new GetElements();
		this.pFeature = new FeatureElements();
		this.pFormula = new FormulaElements();
		this.pEquality = new EqualityElements();
		this.pBinaryFormula = new BinaryFormulaElements();
		this.pIf = new IfElements();
		this.pXor = new XorElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pUnaryFormula = new UnaryFormulaElements();
		this.pNot = new NotElements();
		this.pPredicate = new PredicateElements();
		this.pIsEmpty = new IsEmptyElements();
		this.pGreater = new GreaterElements();
		this.pGreaterEqual = new GreaterEqualElements();
		this.pSmaller = new SmallerElements();
		this.pSmallerEqual = new SmallerEqualElements();
		this.pQuantifier = new QuantifierElements();
		this.pForAll = new ForAllElements();
		this.pExists = new ExistsElements();
		this.pPrimary = new PrimaryElements();
		this.pConstant = new ConstantElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.sidiff.validation.laguage.fol.FirstOrderLogic".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//ConstraintRuleBase:
	//	"domain" domain=STRING
	//	constraints+=Constraint;
	public ConstraintRuleBaseElements getConstraintRuleBaseAccess() {
		return pConstraintRuleBase;
	}
	
	public ParserRule getConstraintRuleBaseRule() {
		return getConstraintRuleBaseAccess().getRule();
	}
	
	//Constraint:
	//	'context' variable=Variable ':' formula=Formula;
	public ConstraintElements getConstraintAccess() {
		return pConstraint;
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}
	
	//// terms:
	//Term:
	//	Variable | Function;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}
	
	//Variable:
	//	type=ID name=ID;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//Function Term:
	//	GetTerm
	public FunctionElements getFunctionAccess() {
		return pFunction;
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}
	
	//GetTerm Term:
	//	{GetTerm} name=[Variable] feature=Get?
	public GetTermElements getGetTermAccess() {
		return pGetTerm;
	}
	
	public ParserRule getGetTermRule() {
		return getGetTermAccess().getRule();
	}
	
	//Get:
	//	"." (type=ID "::")? name=[ecore::EStructuralFeature|Feature] next=Get?;
	public GetElements getGetAccess() {
		return pGet;
	}
	
	public ParserRule getGetRule() {
		return getGetAccess().getRule();
	}
	
	////Get returns Term:
	// //	Variable ({Get.context=current} "." feature=[ecore::EStructuralFeature|Feature])*;
	////  Variable ({Get.context=current} "." feature=ID)*;
	//Feature:
	//	ID;
	public FeatureElements getFeatureAccess() {
		return pFeature;
	}
	
	public ParserRule getFeatureRule() {
		return getFeatureAccess().getRule();
	}
	
	//// equality:
	//Formula:
	//	Equality;
	public FormulaElements getFormulaAccess() {
		return pFormula;
	}
	
	public ParserRule getFormulaRule() {
		return getFormulaAccess().getRule();
	}
	
	//Equality Formula:
	//	BinaryFormula ({Equality.left=current} "=" right=BinaryFormula)*
	public EqualityElements getEqualityAccess() {
		return pEquality;
	}
	
	public ParserRule getEqualityRule() {
		return getEqualityAccess().getRule();
	}
	
	/// * 
	// * Precedence: not, and, or, xor, if
	// * 
	// * To define the precedence we must write the rule for the operator with less precedence in 
	// * terms of the rule for the operator with higher precedence. This means that in the grammar, 
	// * the rules for operators with less precedence are defined first.
	// * / // binary formulas:
	//// TODO: How to make If, Xor,... inherit from BinaryFormula?
	//// http://www.lorenzobettini.it/2014/02/switching-from-an-inferred-ecore-model-to-an-imported-one-in-your-xtext-grammar/
	//BinaryFormula Formula:
	//	If
	public BinaryFormulaElements getBinaryFormulaAccess() {
		return pBinaryFormula;
	}
	
	public ParserRule getBinaryFormulaRule() {
		return getBinaryFormulaAccess().getRule();
	}
	
	//If Formula:
	//	Xor ({If.left=current} "implies" right=Xor)*
	public IfElements getIfAccess() {
		return pIf;
	}
	
	public ParserRule getIfRule() {
		return getIfAccess().getRule();
	}
	
	//Xor Formula:
	//	Or ({Xor.left=current} "xor" right=Or)*
	public XorElements getXorAccess() {
		return pXor;
	}
	
	public ParserRule getXorRule() {
		return getXorAccess().getRule();
	}
	
	//Or Formula:
	//	And ({Or.left=current} "or" right=And)*
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Formula:
	//	Greater ({And.left=current} "and" right=Greater)*
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//// unary formulas:
	//UnaryFormula Formula:
	//	Not
	public UnaryFormulaElements getUnaryFormulaAccess() {
		return pUnaryFormula;
	}
	
	public ParserRule getUnaryFormulaRule() {
		return getUnaryFormulaAccess().getRule();
	}
	
	//Not UnaryFormula:
	//	{Not} "not(" not=Formula ")"
	public NotElements getNotAccess() {
		return pNot;
	}
	
	public ParserRule getNotRule() {
		return getNotAccess().getRule();
	}
	
	//// predicates (term -> boolean):
	//Predicate Formula:
	//	IsEmpty
	public PredicateElements getPredicateAccess() {
		return pPredicate;
	}
	
	public ParserRule getPredicateRule() {
		return getPredicateAccess().getRule();
	}
	
	//IsEmpty:
	//	"isEmpty(" term=[Term] ")";
	public IsEmptyElements getIsEmptyAccess() {
		return pIsEmpty;
	}
	
	public ParserRule getIsEmptyRule() {
		return getIsEmptyAccess().getRule();
	}
	
	//// TODO: left/right should be of type Term
	//Greater Formula:
	//	GreaterEqual ({Greater.left=current} ">" right=GreaterEqual)*
	public GreaterElements getGreaterAccess() {
		return pGreater;
	}
	
	public ParserRule getGreaterRule() {
		return getGreaterAccess().getRule();
	}
	
	//GreaterEqual Formula:
	//	Smaller ({GreaterEqual.left=current} ">=" right=Smaller)*
	public GreaterEqualElements getGreaterEqualAccess() {
		return pGreaterEqual;
	}
	
	public ParserRule getGreaterEqualRule() {
		return getGreaterEqualAccess().getRule();
	}
	
	//Smaller Formula:
	//	SmallerEqual ({Smaller.left=current} "<" right=SmallerEqual)*
	public SmallerElements getSmallerAccess() {
		return pSmaller;
	}
	
	public ParserRule getSmallerRule() {
		return getSmallerAccess().getRule();
	}
	
	//SmallerEqual Formula:
	//	Primary ({SmallerEqual.left=current} "<=" right=Primary)*
	public SmallerEqualElements getSmallerEqualAccess() {
		return pSmallerEqual;
	}
	
	public ParserRule getSmallerEqualRule() {
		return getSmallerEqualAccess().getRule();
	}
	
	//// quantifier
	//Quantifier Formula:
	//	ForAll | Exists
	public QuantifierElements getQuantifierAccess() {
		return pQuantifier;
	}
	
	public ParserRule getQuantifierRule() {
		return getQuantifierAccess().getRule();
	}
	
	//ForAll Quantifier:
	//	{ForAll} "forAll(" name=Variable "in" iteration=Term ":" formula=Formula ")"
	public ForAllElements getForAllAccess() {
		return pForAll;
	}
	
	public ParserRule getForAllRule() {
		return getForAllAccess().getRule();
	}
	
	//Exists Quantifier:
	//	{Exists} "exists(" name=Variable "in" iteration=Term ":" formula=Formula ")"
	public ExistsElements getExistsAccess() {
		return pExists;
	}
	
	public ParserRule getExistsRule() {
		return getExistsAccess().getRule();
	}
	
	//// general:
	//Primary Formula:
	//	'(' Formula ')' | UnaryFormula | Quantifier | Predicate | Constant
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//Constant Term:
	//	{IntConstant} value=INT | {StringConstant} value=STRING | {BoolConstant} value=('true' | 'false') | {VariableRef}
	//	variable=[Variable]
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
