/*
 * generated by Xtext 2.10.0
 */
package org.sidiff.validation.laguage.fol.generator

import java.util.Collections
import java.util.HashMap
import java.util.Map
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.emf.ecore.util.EcoreUtil.Copier
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.sidiff.validation.laguage.fol.firstOrderLogic.And
import org.sidiff.validation.laguage.fol.firstOrderLogic.Constraint
import org.sidiff.validation.laguage.fol.firstOrderLogic.ConstraintRuleBase
import org.sidiff.validation.laguage.fol.firstOrderLogic.Equality
import org.sidiff.validation.laguage.fol.firstOrderLogic.Exists
import org.sidiff.validation.laguage.fol.firstOrderLogic.ForAll
import org.sidiff.validation.laguage.fol.firstOrderLogic.Formula
import org.sidiff.validation.laguage.fol.firstOrderLogic.Get
import org.sidiff.validation.laguage.fol.firstOrderLogic.GetTerm
import org.sidiff.validation.laguage.fol.firstOrderLogic.Greater
import org.sidiff.validation.laguage.fol.firstOrderLogic.GreaterEqual
import org.sidiff.validation.laguage.fol.firstOrderLogic.If
import org.sidiff.validation.laguage.fol.firstOrderLogic.IsEmpty
import org.sidiff.validation.laguage.fol.firstOrderLogic.Not
import org.sidiff.validation.laguage.fol.firstOrderLogic.Or
import org.sidiff.validation.laguage.fol.firstOrderLogic.Smaller
import org.sidiff.validation.laguage.fol.firstOrderLogic.SmallerEqual
import org.sidiff.validation.laguage.fol.firstOrderLogic.Variable
import org.sidiff.validation.laguage.fol.firstOrderLogic.Xor
import org.sidiff.validation.laguage.fol.firstOrderLogic.IntConstant
import org.sidiff.validation.laguage.fol.firstOrderLogic.StringConstant
import org.sidiff.validation.laguage.fol.firstOrderLogic.BoolConstant
import org.sidiff.validation.laguage.fol.firstOrderLogic.VariableRef

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class FirstOrderLogicGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var names = new HashMap<Object, String>();
		
		var constraintCounter = 0
		var variableCounter = 0
		var pathCounter = 0
		
		var ruleBase = getRuleBase(resource)
		var packageImportClass = getPackageImportClass(ruleBase.packageImport)
		
		var packageName = resource.URI.trimFileExtension.lastSegment
		var className = 'ConsistencyRuleLibrary' + packageImportClass

		var code = 
			'''
			package «packageName»;
			
			import java.util.ArrayList;
			import java.util.HashMap;
			import java.util.List;
			import java.util.Map;
			
			import «ruleBase.packageImport»;
			
			import org.sidiff.repair.validation.test.library.*;
			
			import org.sidiff.repair.validation.*;
			import org.sidiff.repair.validation.formulas.binary.*;
			import org.sidiff.repair.validation.formulas.predicates.*;
			import org.sidiff.repair.validation.formulas.quantifiers.*;
			import org.sidiff.repair.validation.formulas.unary.*;
			import org.sidiff.repair.validation.terms.*;
			import org.sidiff.repair.validation.terms.functions.*;
			
			public class «className» extends ConsistencyRuleLibrary {
				
				private static String documentType = «packageImportClass».eINSTANCE.getNsURI();
					
				private static «packageImportClass» DOMAIN = «packageImportClass».eINSTANCE;
				
				private static Map<String, ConsistencyRule> rules = new HashMap<>();
					
				static {
					«FOR constraint : ruleBase.constraints»
						addConsistencyRule(create«constraint.name»Rule());
					«ENDFOR»
				}
				
				private static void addConsistencyRule(ConsistencyRule rule) {
					rules.put(rule.getName(), rule);
				}
				
				@Override	
				public String getDocumentType() {
					return documentType;
				}
				
				@Override
				public List<ConsistencyRule> getConsistencyRules() {
					return new ArrayList<>(rules.values());
				}
				
				@Override
				public ConsistencyRule getConsistencyRule(String name) {
					return rules.get(name);
				}
					
				«FOR constraint : ruleBase.constraints»
				public static ConsistencyRule create«constraint.name»Rule() {
					
					«FOR variable : constraint.eAllContents.filter(typeof(Variable)).toIterable»
						«compile(variable, variableCounter++, names)»
					«ENDFOR»
				
					«FOR getTerm : constraint.eAllContents.filter(typeof(GetTerm)).toIterable»
						«compile(getTerm, pathCounter++, names)»
					«ENDFOR»
				
					«compile(constraint, constraintCounter++, names)»
					
					«var ruleName = 'rule_' + constraint.name»
					ConsistencyRule «ruleName» = new ConsistencyRule(DOMAIN.get«constraint.variable.type»(), «names.get(constraint.variable)», «names.get(constraint)»);
					«ruleName».setName("«constraint.name»");
					«ruleName».setMessage("«constraint.message»");
					
					return «ruleName»;
				}
				«ENDFOR»
			}
			'''
		
		fsa.generateFile(packageName + '/' + className + '.java', code)
		saveAsXMI(resource);
	}
	
	def String getPackageImportClass(String packageImport) {
		return packageImport.subSequence(packageImport.lastIndexOf('.') + 1, packageImport.length) as String 
	}
	
	def ConstraintRuleBase getRuleBase(Resource resource) {
		return (resource.contents.get(0) as ConstraintRuleBase)
	}
	
	def String compile(Variable variable, int counter, HashMap<Object, String> names) {
		var name = 'v' + counter + '_' + variable.name;
		names.put(variable, name)
		
		return '''Variable «name» = new Variable("«variable.name»");'''
	}
	
	def String compile(GetTerm path, int counter, HashMap<Object, String> names) {
		
		// Term t1_m_receiveEvent_covered =
		var name = '''t«counter»_«path.eAllContents.filter(typeof(Get)).map[name.name].join('_')»'''
		var getVariable = 'Term ' + name + ' = '
		names.put(path, name)
		
		//new Get(new Get(m, DOMAIN.getMessage_ReceiveEvent()), DOMAIN.getInteractionFragment_Covered());
		var code = new StringBuffer('new Get(' + names.get(path.name) + ', ' + compile(path.feature.name) + ')')
		compile(path.feature.next, code)
		
		return getVariable + code + ';'
	}
	
	def void compile(Get get, StringBuffer code) {
		
		if (get != null) {
			code.insert(0, 'new Get(')
			code.append(', ' + compile(get.name) + ')')
		
			compile(get.next, code)
		}
	}
	
	def String compile(EStructuralFeature featue) {
		return 'DOMAIN.get' + featue.containerClass.simpleName + '_' + featue.name.toFirstUpper + '()'
	}
	
	def String compile(Constraint constraint, int constraintCounter, HashMap<Object, String> names) {
		var name = 'constraint' + constraintCounter + '_' + constraint.name
		names.put(constraint, name)
		
		return 'Formula ' + name + ' = ' + compileFormula(constraint.formula, names) + ';'
	}
	
	def dispatch String compileFormula(Formula formula, HashMap<Object, String> names) {
		return 'MISSING_FORMULA'
	}
	
	def dispatch String compileFormula(Equality equality, HashMap<Object, String> names) {
		return 'new Equality(' + compileFormula(equality.left, names) + ', ' + compileFormula(equality.right, names)  + ')'
	}
	
	def dispatch String compileFormula(If ifFormula, HashMap<Object, String> names) {
		return 'new If(' + compileFormula(ifFormula.left, names) + ', ' + compileFormula(ifFormula.right, names)  + ')'
	}
	
	def dispatch String compileFormula(Xor xor, HashMap<Object, String> names) {
		return 'new Xor(' + compileFormula(xor.left, names) + ', ' + compileFormula(xor.right, names)  + ')'
	}
	
	def dispatch String compileFormula(Or or, HashMap<Object, String> names) {
		return 'new Or(' + compileFormula(or.left, names) + ', ' + compileFormula(or.right, names)  + ')'
	}
	
	def dispatch String compileFormula(And and, HashMap<Object, String> names) {
		return 'new And(' + compileFormula(and.left, names) + ', ' + compileFormula(and.right, names)  + ')'
	}
	
	def dispatch String compileFormula(Not not, HashMap<Object, String> names) {
		return 'new Not(' + compileFormula(not.not, names) + ')'
	}
	
	def dispatch String compileFormula(IsEmpty isEmpty, HashMap<Object, String> names) {
		return 'new IsEmpty(' + compileFormula(isEmpty.term, names) + ')'
	}
	
	def dispatch String compileFormula(Greater greater, HashMap<Object, String> names) {
		return 'new Greater(' + compileFormula(greater.left, names) + ', ' + compileFormula(greater.right, names)  + ')'
	}
	
	def dispatch String compileFormula(GreaterEqual greaterEqual, HashMap<Object, String> names) {
		return 'new GreaterEqual(' + compileFormula(greaterEqual.left, names) + ', ' + compileFormula(greaterEqual.right, names)  + ')'
	}
	
	def dispatch String compileFormula(Smaller smaller, HashMap<Object, String> names) {
		return 'new Smaller(' + compileFormula(smaller.left, names) + ', ' + compileFormula(smaller.right, names)  + ')'
	}
	
	def dispatch String compileFormula(SmallerEqual smallerEqual, HashMap<Object, String> names) {
		return 'new SmallerEqual(' + compileFormula(smallerEqual.left, names) + ', ' + compileFormula(smallerEqual.right, names)  + ')'
	}
	
	def dispatch String compileFormula(ForAll forAll, HashMap<Object, String> names) {
		return 'new ForAll(' + names.get(forAll.name) + ', ' + names.get(forAll.iteration) +  ', '  + compileFormula(forAll.formula, names) + ')'
	}
	
	def dispatch String compileFormula(Exists exists, HashMap<Object, String> names) {
		return 'new Exists(' + names.get(exists.name) + ', ' + names.get(exists.iteration) +  ', '  + compileFormula(exists.formula, names) + ')'
	}
	
	def dispatch String compileFormula(IntConstant integer, HashMap<Object, String> names) {
		return 'new Constant(' + integer.value + ')'
	}
	
	def dispatch String compileFormula(StringConstant string, HashMap<Object, String> names) {
		return 'new Constant(' + string.value + ')'
	}
	
	def dispatch String compileFormula(BoolConstant bool, HashMap<Object, String> names) {
		return 'new Constant(' + bool.value + ')'
	}
	
	def dispatch String compileFormula(VariableRef variable, HashMap<Object, String> names) {
		return names.get(variable.variable)
	}
	 
	def static void saveAsXMI(Resource resource) {
		var root = resource.contents.get(0)
		var trace = deepCopy(root)
		
		var copyRoot = trace.get(root)
		var resourceSet = new ResourceSetImpl();
		
	 	var xmiResource = resourceSet.createResource(resource.URI.trimFileExtension.appendFileExtension("xmi"));
		xmiResource.contents.add(copyRoot);
		
		xmiResource.save(Collections.emptyMap());
	}
	
	/**
	 * Creates a deep copy (i.e. full tree content) of the given object.
	 * 
	 * @param original
	 *            The root object which will be copied.
	 * @return The copy trace: Original -> Copy
	 */
	def static Map<EObject, EObject> deepCopy(EObject original) {

		// Copier = Map: Original -> Copy
		var copier = new Copier();

		// Root:
		copier.copy(original);

		// References:
		copier.copyReferences();

		return copier;
	}
}
