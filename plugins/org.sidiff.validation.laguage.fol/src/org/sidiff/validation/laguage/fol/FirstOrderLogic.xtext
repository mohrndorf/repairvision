grammar org.sidiff.validation.laguage.fol.FirstOrderLogic with org.eclipse.xtext.common.Terminals

generate firstOrderLogic "http://www.sidiff.org/validation/laguage/fol/FirstOrderLogic"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

ConstraintRuleBase:
	"domain" domain=STRING 'import' packageImport=STRING 
	constraints+=Constraint;

Constraint:
	'name' name=STRING 'message' message=STRING 'context' variable=Variable ':' formula=Formula;

// terms:

Term:
	Variable | Function;
	
Variable:
	type=ID name=ID;
	
Function returns Term: 
//	Get
	GetTerm;
	
GetTerm returns Term:
	{GetTerm} name=[Variable] (feature=Get)?;

Get:
	"." (type=ID "::" )? name=[ecore::EStructuralFeature|Feature] (next=Get)?;

//Get returns Term:
//	Variable ({Get.context=current} "." feature=[ecore::EStructuralFeature|Feature])*;
//  Variable ({Get.context=current} "." feature=ID)*;

Feature returns ecore::EString:
    ID;
    
// equality:

Formula:
	Equality;
	
Equality returns Formula:
	BinaryFormula ({Equality.left=current} "=" right=BinaryFormula)*;

/* 
 * Precedence: not, and, or, xor, if
 * 
 * To define the precedence we must write the rule for the operator with less precedence in 
 * terms of the rule for the operator with higher precedence. This means that in the grammar, 
 * the rules for operators with less precedence are defined first.
 */

// binary formulas:
// TODO: How to make If, Xor,... inherit from BinaryFormula?
// http://www.lorenzobettini.it/2014/02/switching-from-an-inferred-ecore-model-to-an-imported-one-in-your-xtext-grammar/

BinaryFormula returns Formula:
	If;

If returns Formula:
	Xor ({If.left=current} "implies" right=Xor)*;

Xor returns Formula:
	Or ({Xor.left=current} "xor" right=Or)*;

Or returns Formula:
	And ({Or.left=current} "or" right=And)*;

And returns Formula:
	Greater ({And.left=current} "and" right=Greater)*;

// unary formulas:

UnaryFormula returns Formula :
	Not;

Not returns UnaryFormula:
	{Not} "not(" not=Formula ")";
	
// predicates (term -> boolean):

Predicate returns Formula:
	IsEmpty;

IsEmpty:
	"isEmpty(" term=Term ")";

// TODO: left/right should be of type Term
Greater returns Formula:
	GreaterEqual ({Greater.left=current} ">" right=GreaterEqual)*;
	
GreaterEqual returns Formula:
	Smaller ({GreaterEqual.left=current} ">=" right=Smaller)*;

Smaller returns Formula:
	SmallerEqual ({Smaller.left=current} "<" right=SmallerEqual)*;
	
SmallerEqual returns Formula:
	Primary ({SmallerEqual.left=current} "<=" right=Primary)*;
	
// quantifier

Quantifier returns Formula:
	ForAll | Exists;

ForAll returns Quantifier:
	{ForAll} "forAll(" name=Variable "in" iteration=Term ":" formula=Formula ")";
	
Exists returns Quantifier:
	{Exists} "exists(" name=Variable "in" iteration=Term ":" formula=Formula ")";

// general:

Primary returns Formula:
	'(' Formula ')' | UnaryFormula | Quantifier | Predicate | Constant;
	
Constant returns Term:
	{IntConstant} value=INT |
	{StringConstant} value=STRING |
	{BoolConstant} value=('true' | 'false') |
	{VariableRef} variable=[Variable];